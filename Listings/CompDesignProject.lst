C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE COMPDESIGNPROJECT
OBJECT MODULE PLACED IN .\Objects\CompDesignProject.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE CompDesignProject.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\CompDe
                    -signProject.lst) OBJECT(.\Objects\CompDesignProject.obj)

line level    source

   1          /* Auth: Megan Bird
   2           * File: CompDesignProject.c
   3           * Course: CEEN-4330 – Microprocessor System Design – University of Nebraska-Lincoln
   4           * Lab: Project
   5           * Date: 3/14/2017
   6           * Desc: 8051 program with ROM, RAM, and I/O
   7           */
   8           
   9          #include <REGX55.H>
  10          #include <stdio.h>
  11          #include <absacc.h>
  12          
  13          // P1
  14          sbit P1_0 = P1^0;
  15          sbit P1_1 = P1^1;
  16          
  17          // P3
  18          sbit P3_0 = P3^0;
  19          sbit P3_1 = P3^1;
  20          sbit P3_2 = P3^2;
  21          sbit P3_3 = P3^3;
  22          sbit P3_4 = P3^4;
  23          sbit P3_5 = P3^5;
  24          sbit P3_6 = P3^6;
  25          sbit P3_7 = P3^7;
  26          
  27          // Keypad
  28          sbit kCol1  = P1^7;
  29          sbit kCol2  = P1^6;
  30          sbit kCol3  = P1^5;
  31          sbit kCol4  = P1^4;
  32          sbit kRow1  = P1^3;
  33          sbit kRow2  = P1^2;
  34          sbit kRow3  = P1^1;
  35          sbit kRow4  = P1^0;
  36          sbit cs_keypad = P3^1;          // latch
  37          sbit oe_keypad = P3^2;
  38          
  39          // Seven-Segment Display
  40          sfr sevenSegPort = 0x90;
  41          sbit cs_sevenSeg = P3^0;        // latch
  42          
  43          // LCD
  44          sbit cs_lcd = P3^3;                             // latch
  45          sbit rs_lcd = P3^4;                             // reg select
  46          sbit e_lcd  = P3^5;                             // enable
  47          // rw tied to ground to always enable read
  48          sfr lcdPort = 0x90;
  49          
  50          // ADC
  51          sbit oe_adc = P3^3;                             // latch output enable
  52          sbit wr_adc = P3^4;                             // WR line of ADC
  53          sfr adcPort = 0x90;
  54          
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 2   

  55          // RTC
  56          sbit rtc_data0 = P1^0;
  57          sbit rtc_data1 = P1^1;
  58          sbit rtc_data2 = P1^2;
  59          sbit rtc_data3 = P1^3;
  60          sbit rtc_add0 = P1^4;
  61          sbit rtc_add1 = P1^5;
  62          sbit rtc_add2 = P1^6;
  63          sbit rtc_add3 = P1^7;
  64          sfr rtcPort = 0x90;
  65          
  66          // Mission Control
  67          enum {ctrl_off,
  68                                  ctrl_ss_latch,
  69                                  ctrl_kp_oe,
  70                                  ctrl_kp_oelatch,
  71                                  ctrl_lcd_cmd_start,
  72                                  ctrl_lcd_cmd_finish,
  73                                  ctrl_lcd_data_start,
  74                                  ctrl_lcd_data_finish };
  75          
  76          enum {ctrl_adc_start = 1,
  77                                  ctrl_rtc_rd,
  78                                  ctrl_adc_finish,
  79                                  ctrl_rtc_cs1,
  80                                  ctrl_rtc_cs0 = 6,
  81                                  ctrl_rtc_wr };
  82          
  83          sbit dec0 = P3^0;
  84          sbit dec1 = P3^1;               
  85          sbit dec2 = P3^2;
  86          sbit dec3 = P3^3;
  87          sbit dec4 = P3^4;
  88          sbit dec5 = P3^5;
  89          
  90          // Menus
  91          
  92          enum {  menu_main,
  93                          menu_memory,
  94                          menu_io };
  95          
  96          // ======================= prototypes =========================== //
  97          
  98          typedef unsigned char byte;
  99          typedef unsigned short word;
 100          typedef enum { false, true } bool;
 101          
 102          struct keypad_data {
 103                  bool k1;
 104                  bool k2;
 105                  bool k3;
 106                  bool k4;
 107                  bool k5;
 108                  bool k6;
 109                  bool k7;
 110                  bool k8;
 111                  bool k9;
 112                  bool k0;
 113                  bool kA;
 114                  bool kB;
 115                  bool kC;
 116                  bool kD;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 3   

 117                  bool kstar;
 118                  bool kpound;
 119          };
 120          
 121          struct time_data {
 122                  byte seconds;
 123                  byte minutes;
 124                  byte hours;
 125                  byte days;
 126                  byte months;
 127                  byte years;
 128                  byte week;
 129          };
 130          
 131          //------- high level prototyeps -------//
 132          void mainMenu( void );
 133          void memoryMenu( void );
 134          void ioMenu( void );
 135          void dumpMenu( void );
 136          void moveMenu( void );
 137          void editMenu( void );
 138          void findMenu( void );
 139          void tempMenu( void );
 140          void sevenSegMenu( void );
 141          void timeMenu( void );
 142          void stopwatchMenu( void );
 143          
 144          word input4Hex( void );
 145          byte input2Hex( void );
 146          word inputHex( void );
 147          void waitForKeyRelease( void );
 148          
 149          //------- driver prototypes -------//
 150          void latchSevenSeg( void );
 151          void latchKeypad( void );
 152          void outputSevenSeg( char character );
 153          struct keypad_data getKeysPressed( void );
 154          void displayKeyPressed( struct keypad_data keypad );
 155          
 156          void lcdCmd( byte cmd );
 157          void lcdData( byte dat );
 158          void lcdInit( void );
 159          void lcdClear( void );
 160          void lcdChar( byte character );
 161          void lcdString( volatile char *string );
 162          void lcdLine( int line );
 163          void lcdHexWord( word hex );
 164          void lcdHexByte( byte hex );
 165          void lcdAsciiByte( byte hex );
 166          
 167          float getTemp( void );
 168          
 169          void rtcInit( void );
 170          void rtcBusy( void );
 171          void rtcWrite( byte duhdata );
 172          byte rtcRead( byte duhaddress );
 173          void rtcRegWrite( byte duhstuff );
 174          byte rtcRegRead( byte duhstuff );
 175          void rtcSetTime( struct time_data time );
 176          struct time_data rtcGetTime( void );
 177          void rtcPrintTime( struct time_data *time );
 178          
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 4   

 179          void missionControl1( int dec );
 180          void missionControl2( int dec );
 181          void msDelay( unsigned msecs );
 182          
 183          // ======================== main ================================ //
 184          
 185          void main(void) {
 186   1              
 187   1              missionControl1( ctrl_off );
 188   1              missionControl2( ctrl_off );
 189   1              
 190   1              lcdInit();
 191   1              rtcInit();
 192   1      
 193   1              mainMenu();             // Enter main program
 194   1      
 195   1              while(1); // Stay off the streets
 196   1      
 197   1      } // end main()
 198          
 199          // ======================= functions ============================ //
 200          
 201          void mainMenu( void ) { 
 202   1      
 203   1              struct keypad_data keypad;
 204   1      
 205   1              while(1) {
 206   2      
 207   2                      char MenuStr1[] = "Megan Bird CEEN 4330`";
 208   2                      char MenuStr2[] = "--------------------`";
 209   2                      char MenuStr3[] = "Main Menu`";
 210   2                      char MenuStr4[] = "1 : Memory   2 : I/O`";
 211   2              
 212   2                      lcdClear();
 213   2                      lcdString( &MenuStr1 );
 214   2                      lcdLine(2);
 215   2                      lcdString( &MenuStr2 );
 216   2                      lcdLine(3);
 217   2                      lcdString( &MenuStr3 );
 218   2                      lcdLine(4);
 219   2                      lcdString( &MenuStr4 );
 220   2              
 221   2                      while(1) {      
 222   3                              keypad = getKeysPressed();
 223   3                      
 224   3                              if( keypad.k1 == true ) {
 225   4                                      waitForKeyRelease();
 226   4                                      memoryMenu();
 227   4                                      break;
 228   4                              }
 229   3                              else if( keypad.k2 == true ) {
 230   4                                      waitForKeyRelease();
 231   4                                      ioMenu();
 232   4                                      break;
 233   4                              }
 234   3                      } // end option while
 235   2      
 236   2              } // end main while
 237   1      
 238   1      } // end choiceMainMenu()
 239          
 240          // -------------------------------------------------------------- //
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 5   

 241          
 242          void memoryMenu( void ) {
 243   1      
 244   1              struct keypad_data keypad;
 245   1              bool exit = false;
 246   1      
 247   1              while( exit == false ) {
 248   2      
 249   2                      char MenuStr1[] = "Memory Menu`";
 250   2                      char MenuStr2[] = "1 : Dump    2 : Move`";
 251   2                      char MenuStr3[] = "3 : Edit    4 : Find`";
 252   2                      char MenuStr4[] = "# : Return to Main  `";
 253   2              
 254   2                      lcdClear();
 255   2                      lcdString( &MenuStr1 );
 256   2                      lcdLine(2);
 257   2                      lcdString( &MenuStr2 );
 258   2                      lcdLine(3);
 259   2                      lcdString( &MenuStr3 );
 260   2                      lcdLine(4);
 261   2                      lcdString( &MenuStr4 );
 262   2              
 263   2                      while(1) {      
 264   3                              keypad = getKeysPressed();
 265   3                      
 266   3                              if( keypad.kpound == true ) {
 267   4                                      exit = true;
 268   4                                      waitForKeyRelease();
 269   4                                      break;
 270   4                              }
 271   3                              else if( keypad.k1 == true ) {
 272   4                                      waitForKeyRelease();
 273   4                                      dumpMenu();
 274   4                                      break;
 275   4                              }
 276   3                              else if( keypad.k2 == true ) {
 277   4                                      waitForKeyRelease();
 278   4                                      moveMenu();
 279   4                                      break;
 280   4                              }
 281   3                              else if( keypad.k3 == true ) {
 282   4                                      waitForKeyRelease();
 283   4                                      editMenu();
 284   4                                      break;
 285   4                              }
 286   3                              else if( keypad.k4 == true ) {
 287   4                                      waitForKeyRelease();
 288   4                                      findMenu();
 289   4                                      break;
 290   4                              }
 291   3                      } // end option while
 292   2      
 293   2              } // end main while
 294   1      
 295   1      } // end memoryMenu()
 296          
 297          // -------------------------------------------------------------- //
 298          
 299          void ioMenu( void ) {
 300   1      
 301   1              struct keypad_data keypad;
 302   1              bool exit = false;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 6   

 303   1      
 304   1              while( exit == false ) {
 305   2      
 306   2                      char MenuStr1[] = "I/O Menu`";
 307   2                      char MenuStr2[] = "1 : Temp   2 : 7-Seg`";
 308   2                      char MenuStr3[] = "3 : Time   4 : StopW`";
 309   2                      char MenuStr4[] = "# : Return to Main  `";
 310   2              
 311   2                      lcdClear();
 312   2                      lcdString( &MenuStr1 );
 313   2                      lcdLine(2);
 314   2                      lcdString( &MenuStr2 );
 315   2                      lcdLine(3);
 316   2                      lcdString( &MenuStr3 );
 317   2                      lcdLine(4);
 318   2                      lcdString( &MenuStr4 );
 319   2              
 320   2                      while(1) {      
 321   3                              keypad = getKeysPressed();
 322   3                      
 323   3                              if( keypad.kpound == true ) {
 324   4                                      exit = true;
 325   4                                      waitForKeyRelease();
 326   4                                      break;
 327   4                              }
 328   3                              else if( keypad.k1 == true ) {
 329   4                                      waitForKeyRelease();
 330   4                                      tempMenu();
 331   4                                      break;
 332   4                              }
 333   3                              else if( keypad.k2 == true ) {
 334   4                                      waitForKeyRelease();
 335   4                                      sevenSegMenu();
 336   4                                      break;
 337   4                              }
 338   3                              else if( keypad.k3 == true ) {
 339   4                                      waitForKeyRelease();
 340   4                                      timeMenu();
 341   4                                      break;
 342   4                              }
 343   3                              else if( keypad.k4 == true ) {
 344   4                                      waitForKeyRelease();
 345   4                                      stopwatchMenu();
 346   4                                      break;
 347   4                              }
 348   3                      } // end option while
 349   2      
 350   2              } // end main while
 351   1      
 352   1      } // end ioMenu()
 353          
 354          // -------------------------------------------------------------- //
 355          
 356          void dumpMenu( void ) {
 357   1      
 358   1              struct keypad_data keypad;
 359   1              bool exit;
 360   1              word segment;
 361   1              word block;
 362   1              word offset;
 363   1              byte memVal;
 364   1              int i;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 7   

 365   1              
 366   1              char MenuStr1[] = "Dump Setup`";
 367   1              char MenuStr2[] = "Start Seg Addr: `";
 368   1              char MenuStr3[] = "Block Size: `";
 369   1              char MenuStr4[] = "1:<--  2:-->  #:Exit`";
 370   1      
 371   1              exit = false;
 372   1              segment = 0x0000;
 373   1              block = 0x0000;
 374   1              offset = 0x0000;
 375   1      
 376   1              //----------------//
 377   1              //   Dump Setup   //
 378   1              //----------------//
 379   1      
 380   1              // print header and footer
 381   1              lcdClear();
 382   1              lcdString( &MenuStr1 );
 383   1      
 384   1              // address prompt
 385   1              lcdLine(3);
 386   1              lcdString( &MenuStr2 );
 387   1              // read 4 hex digits from keypad
 388   1              segment = input4Hex(); 
 389   1      
 390   1              // block size prompt
 391   1              lcdLine(4);
 392   1              lcdString( &MenuStr3 );
 393   1              // read 4 hex digits from keypad
 394   1              while( block == 0x0000 ) {
 395   2                      block = input4Hex();
 396   2              }
 397   1      
 398   1              //------------------//
 399   1              //   Dump Display   //
 400   1              //------------------//
 401   1      
 402   1              while( exit == false ) {
 403   2      
 404   2                      // print segment:offset
 405   2                      lcdClear();
 406   2                      lcdHexWord( segment );
 407   2                      lcdChar(':');
 408   2                      lcdHexWord( offset );
 409   2      
 410   2                      // print hex values
 411   2                      lcdLine(2);
 412   2                      for( i = 0; i < 7; i++ ) {
 413   3                              if( (offset + i) < block ) {
 414   4                                      memVal = XBYTE[ (segment * 16) + offset + i ]; // get seg:offset+i
 415   4                                      lcdHexByte( memVal );   // print value
 416   4                                      if( i < 6 ) {
 417   5                                              lcdChar(' ');           // print space if not last one on line
 418   5                                      }
 419   4                              }
 420   3                      }
 421   2      
 422   2                      // print ascii values
 423   2                      lcdLine(3);
 424   2                      for( i = 0; i < 7; i++ ) {
 425   3                              if( (offset + i) < block ) {
 426   4                                      memVal = XBYTE[ (segment * 16) + offset + i ]; // get seg:offset+i
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 8   

 427   4                                      lcdAsciiByte( memVal ); // print value
 428   4                                      lcdChar(' ');
 429   4                                      if( i < 6 ) {
 430   5                                              lcdChar(' ');           // print space if not last one on line
 431   5                                      }
 432   4                              }
 433   3                      }
 434   2      
 435   2                      // print footer
 436   2                      lcdLine(4);
 437   2                      lcdString( &MenuStr4 );         
 438   2                              
 439   2                      while(1) {      
 440   3                              keypad = getKeysPressed();
 441   3                      
 442   3                              if( keypad.kpound == true ) {
 443   4                                      exit = true;
 444   4                                      waitForKeyRelease();
 445   4                                      break;
 446   4                              }
 447   3                              else if( keypad.k1 == true ) {
 448   4                                      waitForKeyRelease();
 449   4                                      // if decremented offset is less than start (0),
 450   4                                      if( offset >= 7 ) {
 451   5                                              //      revert (-7) and do nothing
 452   5                                              offset -= 7;
 453   5                                      }
 454   4                                      break;
 455   4                              }
 456   3                              else if( keypad.k2 == true ) {
 457   4                                      waitForKeyRelease();
 458   4                                      // increment offset by 7
 459   4                                      offset += 7;
 460   4                                      // if incremented offset is past block size,
 461   4                                      if( offset > block ) {
 462   5                                              //      revert (-7) and do nothing
 463   5                                              offset -= 7;
 464   5                                      }
 465   4                                      break;
 466   4                              }
 467   3                      } // end option while
 468   2      
 469   2              } // end main while
 470   1      
 471   1      } // end dumpMenu()
 472          
 473          // -------------------------------------------------------------- //
 474          
 475          void moveMenu( void ) {
 476   1      
 477   1              struct keypad_data keypad;
 478   1              bool exit;
 479   1              word sourceSegment;
 480   1              word destSegment;
 481   1              word block;
 482   1              word offset;
 483   1              byte memVal;
 484   1              int i;
 485   1              
 486   1              char MenuStr1[] = "Move Setup`";
 487   1              char MenuStr2[] = "Source Seg Addr: `";
 488   1              char MenuStr3[] = "Dest Seg Addr: `";
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 9   

 489   1              char MenuStr4[] = "Block Size: `";
 490   1              char MenuStr5[] = "Move Complete`";
 491   1              char MenuStr6[] = "#:Exit`";
 492   1      
 493   1              exit = false;
 494   1              sourceSegment = 0x0000;
 495   1              destSegment = 0x0000;
 496   1              block = 0x0000;
 497   1              offset = 0x0000;
 498   1              i = 0;
 499   1      
 500   1              //----------------//
 501   1              //   Move Setup   //
 502   1              //----------------//
 503   1      
 504   1              // print header and footer
 505   1              lcdClear();
 506   1              lcdString( &MenuStr1 );
 507   1      
 508   1              // source address prompt
 509   1              lcdLine(2);
 510   1              lcdString( &MenuStr2 );
 511   1              // read 4 hex digits from keypad
 512   1              sourceSegment = input4Hex(); 
 513   1      
 514   1              // dest address prompt
 515   1              lcdLine(3);
 516   1              lcdString( &MenuStr3 );
 517   1              // read 4 hex digits from keypad
 518   1              destSegment = input4Hex();
 519   1      
 520   1              // block size prompt
 521   1              lcdLine(4);
 522   1              lcdString( &MenuStr4 );
 523   1              // read 4 hex digits from keypad
 524   1              while( block == 0x0000 ) {
 525   2                      block = input4Hex();
 526   2              }
 527   1      
 528   1              //------------------//
 529   1              //   Move Display   //
 530   1              //------------------//
 531   1      
 532   1              while( exit == false ) {
 533   2      
 534   2                      // print segment:offset
 535   2                      lcdClear();
 536   2                      lcdString( &MenuStr5 );
 537   2                      lcdLine(4);
 538   2                      lcdString( &MenuStr6 );
 539   2      //              lcdHexWord( segment );
 540   2      //              lcdChar(':');
 541   2      //              lcdHexWord( offset );
 542   2                      
 543   2      
 544   2                      // perform move
 545   2                      while( (offset + i) < block ) {
 546   3                              memVal = XBYTE[ (sourceSegment * 16) + offset + i ]; // get sourceSeg:offset+i
 547   3                              XBYTE[ (destSegment * 16) + offset + i ] = memVal;      // move to destSeg:offset+i
 548   3                              i++;
 549   3                      }       
 550   2                              
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 10  

 551   2                      while(1) {      
 552   3                              keypad = getKeysPressed();
 553   3                      
 554   3                              if( keypad.kpound == true ) {
 555   4                                      exit = true;
 556   4                                      waitForKeyRelease();
 557   4                                      break;
 558   4                              }
 559   3      
 560   3                      } // end option while
 561   2      
 562   2              } // end main while
 563   1      
 564   1      } // end moveMenu()
 565          
 566          // -------------------------------------------------------------- //
 567          
 568          void editMenu( void ) {
 569   1      
 570   1              struct keypad_data keypad;
 571   1              bool exit;
 572   1              bool next;
 573   1              word segment;
 574   1              word offset;
 575   1              byte new_value;
 576   1              byte memVal;
 577   1              
 578   1              char MenuStr1[] = "Edit Setup`";
 579   1              char MenuStr2[] = "Segment Addr: `";
 580   1              char MenuStr3[] = "Offset Addr: `";
 581   1              char MenuStr4[] = "New Value: `";
 582   1              char MenuStr5[] = "Edit Complete`";
 583   1              char MenuStr6[] = "0:Continue    #:Exit`";
 584   1      
 585   1              exit = false;
 586   1              next = true;
 587   1              segment = 0x0000;
 588   1              offset = 0x0000;
 589   1              new_value = 0xAA;
 590   1      
 591   1              //----------------//
 592   1              //   Edit Setup   //
 593   1              //----------------//
 594   1      
 595   1              // print header and footer
 596   1              lcdClear();
 597   1              lcdString( &MenuStr1 );
 598   1      
 599   1              // segment address prompt
 600   1              lcdLine(2);
 601   1              lcdString( &MenuStr2 );
 602   1              // read 4 hex digits from keypad
 603   1              segment = input4Hex(); 
 604   1      
 605   1              // offset address prompt
 606   1              lcdLine(3);
 607   1              lcdString( &MenuStr3 );
 608   1              // read 4 hex digits from keypad
 609   1              offset = input4Hex();
 610   1              
 611   1              //------------------//
 612   1              //   Edit Display   //
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 11  

 613   1              //------------------//
 614   1      
 615   1              while( exit == false ) {
 616   2      
 617   2                      if( next == true ) {
 618   3      
 619   3                              // print segment:offset
 620   3                              lcdClear();
 621   3                              lcdHexWord( segment );
 622   3                              lcdChar(':');
 623   3                              lcdHexWord( offset );
 624   3                              lcdChar(' ');
 625   3      
 626   3                              // print current value
 627   3                              memVal = XBYTE[ (segment * 16) + offset ]; // get seg:offset
 628   3                              lcdHexByte( memVal );   // print value
 629   3                      
 630   3                              // new value prompt
 631   3                              lcdLine(2);
 632   3                              lcdString( &MenuStr4 );
 633   3                      
 634   3                              // read 2 hex digits from keypad
 635   3                              new_value = input2Hex();
 636   3                              // store value
 637   3                              XBYTE[ (segment * 16) + offset ] = new_value;   // move to destSeg:offset
 638   3                      
 639   3                              // edit complete
 640   3                              lcdLine(3);
 641   3                              lcdString( &MenuStr5 );
 642   3                      
 643   3                              // exit prompt
 644   3                              lcdLine(4);
 645   3                              lcdString( &MenuStr6 );
 646   3      
 647   3                              offset++;
 648   3      
 649   3                      } // end next if
 650   2                              
 651   2                      while(1) {      
 652   3      
 653   3                              keypad = getKeysPressed();
 654   3                      
 655   3                              if( keypad.kpound == true ) {
 656   4                                      next = false;
 657   4                                      exit = true;
 658   4                                      waitForKeyRelease();
 659   4                                      break;
 660   4                              }
 661   3      
 662   3                              if( keypad.k0 == true ) {
 663   4                                      next = true;
 664   4                                      waitForKeyRelease();
 665   4                                      break;
 666   4                              }
 667   3      
 668   3                      } // end option while
 669   2      
 670   2              } // end main while
 671   1      
 672   1      } // end editMenu()
 673          
 674          // -------------------------------------------------------------- //
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 12  

 675          
 676          void findMenu( void ) {
 677   1      
 678   1              struct keypad_data keypad;
 679   1              bool exit;
 680   1              bool found;
 681   1              word segment;
 682   1              word offset;
 683   1              word block;
 684   1              byte search_value;
 685   1              byte memVal;
 686   1              
 687   1              char MenuStr1[] = "Find Setup`";
 688   1              char MenuStr2[] = "Start Seg Addr: `";
 689   1              char MenuStr3[] = "Block Size: `";
 690   1              char MenuStr4[] = "Search Value: `";
 691   1              char MenuStr5[] = "Value found at`";
 692   1              char MenuStr6[] = "Value not found!`";
 693   1              char MenuStr7[] = "#:Exit`";
 694   1      
 695   1              exit = false;
 696   1              found = false;
 697   1              segment = 0x0000;
 698   1              offset = 0x0000;
 699   1              block = 0x0000;
 700   1              search_value = 0xAA;
 701   1      
 702   1              //----------------//
 703   1              //   Find Setup   //
 704   1              //----------------//
 705   1      
 706   1              // print header and footer
 707   1              lcdClear();
 708   1              lcdString( &MenuStr1 );
 709   1      
 710   1              // start address prompt
 711   1              lcdLine(2);
 712   1              lcdString( &MenuStr2 );
 713   1              // read 4 hex digits from keypad
 714   1              segment = input4Hex(); 
 715   1      
 716   1              // block size prompt
 717   1              lcdLine(3);
 718   1              lcdString( &MenuStr3 );
 719   1              // read 4 hex digits from keypad
 720   1              block = input4Hex();
 721   1      
 722   1              // search value prompt
 723   1              lcdLine(4);
 724   1              lcdString( &MenuStr4 );
 725   1              // read 4 hex digits from keypad
 726   1              search_value = input2Hex();
 727   1              
 728   1              //------------------//
 729   1              //   Find Display   //
 730   1              //------------------//
 731   1      
 732   1              // search block for value
 733   1              while( (offset) < block ) {
 734   2                      memVal = XBYTE[ (segment * 16) + offset ]; // get seg:offset+i
 735   2                      if( memVal == search_value ) {
 736   3                         found = true;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 13  

 737   3                         break;
 738   3                      }
 739   2                      offset++;
 740   2              }
 741   1      
 742   1              // print result
 743   1              lcdClear();
 744   1              if( found == true ) {
 745   2                      // Value found at ...
 746   2                      lcdString( &MenuStr5 );
 747   2                      // print segment:offset
 748   2                      lcdLine(2);
 749   2                      lcdHexWord( segment );
 750   2                      lcdChar(':');
 751   2                      lcdHexWord( offset );
 752   2                      // Footer
 753   2                      lcdLine(4);
 754   2                      lcdString( &MenuStr7 );
 755   2              }
 756   1              else {
 757   2                      // Value not found
 758   2                      lcdString( &MenuStr6 );
 759   2                      // Footer
 760   2                      lcdLine(4);
 761   2                      lcdString( &MenuStr7 );
 762   2              }
 763   1      
 764   1              while( exit == false ) {
 765   2                              
 766   2                      while(1) {      
 767   3      
 768   3                              keypad = getKeysPressed();
 769   3                      
 770   3                              if( keypad.kpound == true ) {
 771   4                                      exit = true;
 772   4                                      waitForKeyRelease();
 773   4                                      break;
 774   4                              }
 775   3      
 776   3                      } // end option while
 777   2      
 778   2              } // end main while
 779   1      
 780   1      } // end findMenu()
 781          
 782          // -------------------------------------------------------------- //
 783          
 784          void tempMenu( void ) {
 785   1      
 786   1              struct keypad_data keypad;
 787   1              bool exit = false;
 788   1              int i = 0;
 789   1      
 790   1              while( exit == false ) {
 791   2      
 792   2                      char MenuStr1[] = "Current Temperature`";
 793   2                      char MenuStr2[] = "+00.0 F`";
 794   2                      //char MenuStr3[] = " `";
 795   2                      char MenuStr4[] = "# : Return to I/O   `";
 796   2              
 797   2                      lcdClear();
 798   2                      lcdString( &MenuStr1 );
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 14  

 799   2      
 800   2                      lcdLine(2);
 801   2                      sprintf( MenuStr2, "%+5.1f F`", getTemp() );
 802   2                      lcdString( &MenuStr2 );
 803   2      
 804   2                      //lcdLine(3);
 805   2                      //lcdString( &MenuStr3 );
 806   2                      lcdLine(4);
 807   2                      lcdString( &MenuStr4 );
 808   2              
 809   2                      while(1) {      
 810   3      
 811   3                              // slow LCD temp refresh rate down
 812   3                              if ( i == 1000 ) {
 813   4                                      lcdLine(2);
 814   4                                      sprintf( MenuStr2, "%+5.1f F`", getTemp() );
 815   4                                      lcdString( &MenuStr2 );
 816   4                                      i = 0;
 817   4                              }
 818   3                              else {
 819   4                                      i++;
 820   4                              }
 821   3      
 822   3                              keypad = getKeysPressed();
 823   3                      
 824   3                              if( keypad.kpound == true ) {
 825   4                                      exit = true;
 826   4                                      waitForKeyRelease();
 827   4                                      break;
 828   4                              }
 829   3      
 830   3                      } // end option while
 831   2      
 832   2              } // end main while
 833   1      
 834   1      } // end tempMenu()
 835          
 836          // -------------------------------------------------------------- //
 837          
 838          void sevenSegMenu( void ) {
 839   1      
 840   1              struct keypad_data keypad;
 841   1              bool exit = false;
 842   1              int i = 0;
 843   1      
 844   1              while( exit == false ) {
 845   2      
 846   2                      char MenuStr1[] = "Seven Segment`";
 847   2                      char MenuStr2[] = "Display Demo`";
 848   2                      //char MenuStr3[] = " `";
 849   2                      char MenuStr4[] = "# : Return to I/O`";
 850   2              
 851   2                      lcdClear();
 852   2                      lcdString( &MenuStr1 );
 853   2      
 854   2                      lcdLine(2);
 855   2                      lcdString( &MenuStr2 );
 856   2      
 857   2                      //lcdLine(3);
 858   2                      //lcdString( &MenuStr3 );
 859   2                      lcdLine(4);
 860   2                      lcdString( &MenuStr4 );
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 15  

 861   2              
 862   2                      while(1) {      
 863   3      
 864   3                              keypad = getKeysPressed();
 865   3                      
 866   3                              if( keypad.kpound == true ) {
 867   4                                      exit = true;
 868   4                                      outputSevenSeg('o'); // Turn display off when exiting
 869   4                                      waitForKeyRelease();
 870   4                                      break;
 871   4                              }
 872   3      
 873   3                              switch (i) {
 874   4                                      
 875   4                                      case 0: sevenSegPort = 0xFE; break;
 876   4                                      case 1: sevenSegPort = 0xFD; break;
 877   4                                      case 2: sevenSegPort = 0xFB; break;
 878   4                                      case 3: sevenSegPort = 0xF7; break;
 879   4                                      case 4: sevenSegPort = 0xEF; break;
 880   4                                      case 5: sevenSegPort = 0xDF; break;
 881   4                                      case 6: sevenSegPort = 0xBF; break;
 882   4                                      case 7: sevenSegPort = 0x7F; break;
 883   4                                      default: sevenSegPort = 0xFF; break;
 884   4      
 885   4                              } // end switch
 886   3      
 887   3                              if( i >= 7 ) {
 888   4                                      i = 0;
 889   4                              } else {
 890   4                                      i++;
 891   4                              }
 892   3      
 893   3                              latchSevenSeg();
 894   3                              msDelay(50);
 895   3      
 896   3                      } // end option while
 897   2      
 898   2              } // end main while
 899   1      
 900   1      } // end sevenSegMenu()
 901          
 902          // -------------------------------------------------------------- //
 903          
 904          void timeMenu( void ) {
 905   1      
 906   1              struct keypad_data keypad;
 907   1              bool exit = false;
 908   1              int i = 0;
 909   1              struct time_data time;
 910   1      
 911   1              while( exit == false ) {
 912   2      
 913   2                      char MenuStr1[] = "Real Time Clock`";
 914   2                      //char MenuStr2[] = "<Time>`";
 915   2                      //char MenuStr3[] = " `";
 916   2                      char MenuStr4[] = "# : Return to I/O   `";
 917   2              
 918   2                      lcdClear();
 919   2                      lcdString( &MenuStr1 );
 920   2      
 921   2                      lcdLine(2);
 922   2                      time = rtcGetTime();
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 16  

 923   2                      rtcPrintTime( &time );
 924   2      
 925   2                      //lcdLine(3);
 926   2                      //lcdString( &MenuStr3 );
 927   2                      lcdLine(4);
 928   2                      lcdString( &MenuStr4 );
 929   2              
 930   2                      while(1) {      
 931   3      
 932   3                              // slow LCD time refresh rate down
 933   3                              if ( i == 1000 ) {
 934   4                                      lcdLine(2);
 935   4                                      time = rtcGetTime();
 936   4                                      rtcPrintTime( &time );
 937   4                                      i = 0;
 938   4                              }
 939   3                              else {
 940   4                                      i++;
 941   4                              }
 942   3      
 943   3                              keypad = getKeysPressed();
 944   3                      
 945   3                              if( keypad.kpound == true ) {
 946   4                                      exit = true;
 947   4                                      waitForKeyRelease();
 948   4                                      break;
 949   4                              }
 950   3      
 951   3                      } // end option while
 952   2      
 953   2              } // end main while
 954   1      
 955   1      } // end timeMenu()
 956          
 957          // -------------------------------------------------------------- //
 958          
 959          void stopwatchMenu( void ) {
 960   1      
 961   1              struct keypad_data keypad;
 962   1              struct time_data original_start_time;
 963   1              struct time_data start_time;
 964   1              struct time_data current_time;
 965   1              struct time_data timer;
 966   1              bool exit;
 967   1              bool running;
 968   1              int i;
 969   1      
 970   1              char MenuStr1[] = "Stopwatch`";
 971   1              char MenuStr2[] = "No timer started    `";
 972   1              char MenuStr3[] = "1: Start     2: Stop`";
 973   1              char MenuStr4[] = "3: Clear     #: Exit`";
 974   1      
 975   1              exit = false;
 976   1              running = false;
 977   1              i = 0;
 978   1      
 979   1              // Initial display
 980   1              lcdClear();
 981   1              lcdString( &MenuStr1 );
 982   1              lcdLine(2);
 983   1              lcdString( &MenuStr2 );
 984   1              lcdLine(3);
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 17  

 985   1              lcdString( &MenuStr3 );
 986   1              lcdLine(4);
 987   1              lcdString( &MenuStr4 ); 
 988   1              
 989   1              while( exit == false ) {
 990   2              
 991   2                      while(1) {      
 992   3      
 993   3                              if ( running == true) {
 994   4                                      // slow LCD time refresh rate down
 995   4                                      if ( i == 1000 ) {
 996   5                                              
 997   5                                              current_time = rtcGetTime();
 998   5                                              start_time = original_start_time;
 999   5                      
1000   5                                              //timer = current_time - start_time;
1001   5                                              // seconds
1002   5                                              if( current_time.seconds >= start_time.seconds ) {
1003   6                                                      timer.seconds = current_time.seconds - start_time.seconds;
1004   6                                              }
1005   5                                              else {
1006   6                                                      timer.seconds = current_time.seconds + 60 - start_time.seconds;
1007   6                                                      current_time.minutes--;
1008   6                                              }
1009   5                                              // minutes
1010   5                                              if( current_time.minutes >= start_time.minutes ) {
1011   6                                                      timer.minutes = current_time.minutes - start_time.minutes;
1012   6                                              }
1013   5                                              else {
1014   6                                                      timer.minutes = current_time.minutes + 60 - start_time.minutes;
1015   6                                                      current_time.hours--;
1016   6                                              }
1017   5                                              // hours
1018   5                                              if( current_time.hours >= start_time.hours ) {
1019   6                                                      timer.hours = current_time.hours - start_time.hours;
1020   6                                              }
1021   5                                              else {
1022   6                                                      timer.hours = current_time.hours + 24 - start_time.hours;
1023   6                                                      current_time.days--;
1024   6                                              }
1025   5                                              // days
1026   5                                              if( current_time.days >= start_time.days ) {
1027   6                                                      timer.days = current_time.days - start_time.days;
1028   6                                              }
1029   5                                              else {
1030   6                                                      timer.days = current_time.days + 30 - start_time.days;
1031   6                                                      current_time.months--;
1032   6                                              }
1033   5                                              // months
1034   5                                              if( current_time.months >= start_time.months ) {
1035   6                                                      timer.months = current_time.months - start_time.months;
1036   6                                              }
1037   5                                              else {
1038   6                                                      timer.months = current_time.months + 12 - start_time.months;
1039   6                                                      current_time.years--;
1040   6                                              }
1041   5                                              // years
1042   5                                              timer.years = start_time.years - current_time.years;
1043   5                                              //
1044   5                                              timer.week = current_time.week;
1045   5                      
1046   5                                              lcdLine(2);
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 18  

1047   5                                              rtcPrintTime( &timer );
1048   5                                              i = 0;
1049   5                                      }
1050   4                                      else {
1051   5                                              i++;
1052   5                                      }
1053   4                              } // end running
1054   3              
1055   3                              keypad = getKeysPressed();
1056   3                      
1057   3                              if( keypad.kpound == true ) {
1058   4                                      exit = true;
1059   4                                      waitForKeyRelease();
1060   4                                      break;
1061   4                              }
1062   3                              if( keypad.k1 == true ) {
1063   4                                      // Start timer
1064   4                                      running = true;
1065   4                                      original_start_time = rtcGetTime();
1066   4                                      waitForKeyRelease();
1067   4                                      break;
1068   4                              }
1069   3                              if( keypad.k2 == true ) {
1070   4                                      // Stop timer
1071   4                                      running = false;
1072   4                                      waitForKeyRelease();
1073   4                                      break;
1074   4                              }
1075   3                              if( keypad.k3 == true ) {
1076   4                                      // Clear timer
1077   4                                      running = false;
1078   4                                      lcdLine(2);
1079   4                                      lcdString( &MenuStr2 );
1080   4                                      waitForKeyRelease();
1081   4                                      break;
1082   4                              }
1083   3              
1084   3                      } // end option while
1085   2      
1086   2              } // end main while
1087   1      
1088   1      } // end stopwatchMenu()
1089          
1090          // -------------------------------------------------------------- //
1091          
1092          word input4Hex( void ) {
1093   1      
1094   1              word segment;
1095   1              word input;
1096   1              int i;
1097   1              
1098   1              segment = 0x0000;
1099   1      
1100   1              for( i = 0; i < 4; i++ ) {
1101   2                      segment = segment << 4;
1102   2                      input = inputHex();
1103   2                      segment = segment + input;
1104   2              }
1105   1         
1106   1              return segment;
1107   1      
1108   1      } // end input4Hex()
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 19  

1109          
1110          // -------------------------------------------------------------- //
1111          
1112          byte input2Hex( void ) {
1113   1      
1114   1              byte value;
1115   1              word input;
1116   1              int i;
1117   1              
1118   1              value = 0x00;
1119   1      
1120   1              for( i = 0; i < 2; i++ ) {
1121   2                      value = value << 4;
1122   2                      input = inputHex();
1123   2                      value = value + input;
1124   2              }
1125   1         
1126   1              return value;
1127   1      
1128   1      } // end input2Hex()
1129          
1130          // -------------------------------------------------------------- //
1131          
1132          word inputHex( void ) {
1133   1      
1134   1              struct keypad_data keypad;
1135   1              word value;
1136   1              byte ascii;
1137   1              
1138   1              
1139   1              value = 0xFFFF;
1140   1              ascii = 0x7E;
1141   1              
1142   1              while( value == 0xFFFF ) {
1143   2                
1144   2                      keypad = getKeysPressed();
1145   2      
1146   2                      if( keypad.k0 == true ) {
1147   3                              value = 0x0000;
1148   3                              ascii = 0x30;
1149   3                      }
1150   2                      if( keypad.k1 == true ) {
1151   3                              value = 0x0001;
1152   3                              ascii = 0x31;
1153   3                      }
1154   2                      if( keypad.k2 == true ) {
1155   3                              value = 0x0002;
1156   3                              ascii = 0x32;
1157   3                      }
1158   2                      if( keypad.k3 == true ) {
1159   3                              value = 0x0003;
1160   3                              ascii = 0x33;
1161   3                      }
1162   2                      if( keypad.k4 == true ) {
1163   3                              value = 0x0004;
1164   3                              ascii = 0x34;
1165   3                      }
1166   2                      if( keypad.k5 == true ) {
1167   3                              value = 0x0005;
1168   3                              ascii = 0x35;
1169   3                      }
1170   2                      if( keypad.k6 == true ) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 20  

1171   3                              value = 0x0006;
1172   3                              ascii = 0x36;
1173   3                      }
1174   2                      if( keypad.k7 == true ) {
1175   3                              value = 0x0007;
1176   3                              ascii = 0x37;
1177   3                      }
1178   2                      if( keypad.k8 == true ) {
1179   3                              value = 0x0008;
1180   3                              ascii = 0x38;
1181   3                      }
1182   2                      if( keypad.k9 == true ) {
1183   3                              value = 0x0009;
1184   3                              ascii = 0x39;
1185   3                      }
1186   2                      if( keypad.kA == true ) {
1187   3                              value = 0x000A;
1188   3                              ascii = 0x41;
1189   3                      }
1190   2                      if( keypad.kB == true ) {
1191   3                              value = 0x000B;
1192   3                              ascii = 0x42;
1193   3                      }
1194   2                      if( keypad.kC == true ) {
1195   3                              value = 0x000C;
1196   3                              ascii = 0x43;
1197   3                      }
1198   2                      if( keypad.kD == true ) {
1199   3                              value = 0x000D;
1200   3                              ascii = 0x44;
1201   3                      }
1202   2                      if( keypad.kstar == true ) {
1203   3                              value = 0x000E;
1204   3                              ascii = 0x45;
1205   3                      }
1206   2                      if( keypad.kpound == true ) {
1207   3                              value = 0x000F;
1208   3                              ascii = 0x46;
1209   3                      }
1210   2      
1211   2              } // end while
1212   1      
1213   1              lcdChar( ascii );
1214   1      
1215   1              waitForKeyRelease();
1216   1              return value;   
1217   1      
1218   1      } // end readHex()
1219          
1220          // -------------------------------------------------------------- //
1221          
1222          void waitForKeyRelease( void ) {
1223   1      
1224   1              struct keypad_data keypad;
1225   1              bool exit = false;
1226   1              
1227   1              while( exit == false ) {
1228   2      
1229   2                      exit = true;
1230   2                      keypad = getKeysPressed();
1231   2      
1232   2                      if( keypad.k0 == true ) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 21  

1233   3                              exit = false;
1234   3                      }
1235   2                      if( keypad.k1 == true ) {
1236   3                              exit = false;
1237   3                      }
1238   2                      if( keypad.k2 == true ) {
1239   3                              exit = false;
1240   3                      }
1241   2                      if( keypad.k3 == true ) {
1242   3                              exit = false;
1243   3                      }
1244   2                      if( keypad.k4 == true ) {
1245   3                              exit = false;
1246   3                      }
1247   2                      if( keypad.k5 == true ) {
1248   3                              exit = false;
1249   3                      }
1250   2                      if( keypad.k6 == true ) {
1251   3                              exit = false;
1252   3                      }
1253   2                      if( keypad.k7 == true ) {
1254   3                              exit = false;
1255   3                      }
1256   2                      if( keypad.k8 == true ) {
1257   3                              exit = false;
1258   3                      }
1259   2                      if( keypad.k9 == true ) {
1260   3                              exit = false;
1261   3                      }
1262   2                      if( keypad.kA == true ) {
1263   3                              exit = false;
1264   3                      }
1265   2                      if( keypad.kB == true ) {
1266   3                              exit = false;
1267   3                      }
1268   2                      if( keypad.kC == true ) {
1269   3                              exit = false;
1270   3                      }
1271   2                      if( keypad.kD == true ) {
1272   3                              exit = false;
1273   3                      }
1274   2                      if( keypad.kstar == true ) {
1275   3                              exit = false;
1276   3                      }
1277   2                      if( keypad.kpound == true ) {
1278   3                              exit = false;
1279   3                      }
1280   2      
1281   2              } // end while
1282   1              
1283   1              msDelay(100);     
1284   1      
1285   1      } // end waitForKeyRelease()
1286          
1287          // -------------------------------------------------------------- //
1288          
1289          void latchSevenSeg( void ) {
1290   1              
1291   1      //      cs_sevenSeg = 1;
1292   1      //      cs_sevenSeg = 0;
1293   1              
1294   1              missionControl1( ctrl_ss_latch );
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 22  

1295   1              missionControl1( ctrl_off );
1296   1              
1297   1      } // end latchSevenSeg()
1298          
1299          // -------------------------------------------------------------- //
1300          
1301          void latchKeypad( void ) {
1302   1              
1303   1      //      cs_keypad = 1;
1304   1      //      cs_keypad = 0;
1305   1              
1306   1              missionControl1( ctrl_kp_oelatch );
1307   1              missionControl1( ctrl_kp_oe );
1308   1              
1309   1      } // end latchKeypad()
1310          
1311          
1312          // -------------------------------------------------------------- //
1313          
1314          void outputSevenSeg( char character ) {
1315   1              
1316   1              switch( character ) {
1317   2                      case '0': sevenSegPort = ~0x3F; break;
1318   2                      case '1': sevenSegPort = ~0x06; break;
1319   2                      case '2': sevenSegPort = ~0x5B; break;
1320   2                      case '3': sevenSegPort = ~0x4F; break;
1321   2                      case '4': sevenSegPort = ~0x66; break;
1322   2                      case '5': sevenSegPort = ~0x6D; break;
1323   2                      case '6': sevenSegPort = ~0x7D; break;
1324   2                      case '7': sevenSegPort = ~0x07; break;
1325   2                      case '8': sevenSegPort = ~0x7F; break;
1326   2                      case '9': sevenSegPort = ~0x67; break;
1327   2                      case 'A': sevenSegPort = ~0x77; break;
1328   2                      case 'b': sevenSegPort = ~0x7C; break;
1329   2                      case 'C': sevenSegPort = ~0x39; break;
1330   2                      case 'd': sevenSegPort = ~0x5E; break;
1331   2                      case 'E': sevenSegPort = ~0x79; break;
1332   2                      case 'F': sevenSegPort = ~0x71; break;
1333   2                      case '-': sevenSegPort = 0xBF;  break;
1334   2                      case '.': sevenSegPort = 0x7F;  break;
1335   2                      case 'o': sevenSegPort = 0xFF;  break;  // off
1336   2                      default:  sevenSegPort = 0xAA;                                  // invalid
1337   2              }
1338   1              
1339   1              latchSevenSeg();
1340   1              
1341   1      } // end outputSevenSeg()
1342          
1343          // -------------------------------------------------------------- //
1344          
1345          struct keypad_data getKeysPressed( void ) {
1346   1              
1347   1              struct keypad_data keypad;
1348   1              
1349   1              // enable keypad latch output
1350   1              //oe_keypad = 0;
1351   1              missionControl1( ctrl_kp_oe );
1352   1              
1353   1              // Set keypad columns as outputs & rows as inputs
1354   1              kCol1 = 0;
1355   1              kCol2 = 0;
1356   1              kCol3 = 0;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 23  

1357   1              kCol4 = 0;
1358   1              kRow1 = 1;
1359   1              kRow2 = 1;
1360   1              kRow3 = 1;
1361   1              kRow4 = 1;
1362   1              
1363   1              // scan by columns
1364   1      
1365   1              // column 1
1366   1              kCol1 = 0;
1367   1              kCol2 = 1;
1368   1              kCol3 = 1;
1369   1              kCol4 = 1;
1370   1              latchKeypad();
1371   1              
1372   1              if (kRow1 == 0) {
1373   2                      keypad.k1 = 1;
1374   2              }
1375   1              else {
1376   2                      keypad.k1 = 0;
1377   2              }
1378   1              if (kRow2 == 0) {
1379   2                      keypad.k4 = 1;
1380   2              }
1381   1              else {
1382   2                      keypad.k4 = 0;
1383   2              }
1384   1              if (kRow3 == 0) {
1385   2                      keypad.k7 = 1;
1386   2              }
1387   1              else {
1388   2                      keypad.k7 = 0;
1389   2              }
1390   1              if (kRow4 == 0) {
1391   2                      keypad.kstar = 1;
1392   2              }
1393   1              else {
1394   2                      keypad.kstar = 0;
1395   2              }
1396   1              kCol1 = 1;
1397   1              
1398   1              // column 2
1399   1              kCol2 = 0;
1400   1              latchKeypad();
1401   1              
1402   1              if (kRow1 == 0) {
1403   2                      keypad.k2 = 1;
1404   2              }
1405   1              else {
1406   2                      keypad.k2 = 0;
1407   2              }
1408   1              if (kRow2 == 0) {
1409   2                      keypad.k5 = 1;
1410   2              }
1411   1              else {
1412   2                      keypad.k5 = 0;
1413   2              }
1414   1              if (kRow3 == 0) {
1415   2                      keypad.k8 = 1;
1416   2              }
1417   1              else {
1418   2                      keypad.k8 = 0;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 24  

1419   2              }
1420   1              if (kRow4 == 0) {
1421   2                      keypad.k0 = 1;
1422   2              }
1423   1              else {
1424   2                      keypad.k0 = 0;
1425   2              }
1426   1              kCol2 = 1;
1427   1              
1428   1              // column 3
1429   1              kCol3 = 0;
1430   1              latchKeypad();
1431   1              
1432   1              if (kRow1 == 0) {
1433   2                      keypad.k3 = 1;
1434   2              }
1435   1              else {
1436   2                      keypad.k3 = 0;
1437   2              }
1438   1              if (kRow2 == 0) {
1439   2                      keypad.k6 = 1;
1440   2              }
1441   1              else {
1442   2                      keypad.k6 = 0;
1443   2              }
1444   1              if (kRow3 == 0) {
1445   2                      keypad.k9 = 1;
1446   2              }
1447   1              else {
1448   2                      keypad.k9 = 0;
1449   2              }
1450   1              if (kRow4 == 0) {
1451   2                      keypad.kpound = 1;
1452   2              }
1453   1              else {
1454   2                      keypad.kpound = 0;
1455   2              }
1456   1              kCol3 = 1;
1457   1              
1458   1              // column 4
1459   1              kCol4 = 0;
1460   1              latchKeypad();
1461   1              
1462   1              if (kRow1 == 0) {
1463   2                      keypad.kA = 1;
1464   2              }
1465   1              else {
1466   2                      keypad.kA = 0;
1467   2              }
1468   1              if (kRow2 == 0) {
1469   2                      keypad.kB = 1;
1470   2              }
1471   1              else {
1472   2                      keypad.kB = 0;
1473   2              }
1474   1              if (kRow3 == 0) {
1475   2                      keypad.kC = 1;
1476   2              }
1477   1              else {
1478   2                      keypad.kC = 0;
1479   2              }
1480   1              if (kRow4 == 0) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 25  

1481   2                      keypad.kD = 1;
1482   2              }
1483   1              else {
1484   2                      keypad.kD = 0;
1485   2              }
1486   1              kCol4 = 1;
1487   1              latchKeypad();
1488   1              
1489   1              // disable keypad latch output
1490   1              //oe_keypad = 1;
1491   1              missionControl1( ctrl_off );
1492   1              
1493   1              return keypad; 
1494   1              
1495   1      } // end getKeysPressed()
1496          
1497          // -------------------------------------------------------------- //
1498          
1499          void displayKeyPressed( struct keypad_data keypad ) {
1500   1              
1501   1              if ( keypad.k1 == 1 ) {
1502   2                      outputSevenSeg('1');
1503   2              }
1504   1              else if ( keypad.k2 == 1 ) {
1505   2                      outputSevenSeg('2');
1506   2              }
1507   1              else if ( keypad.k3 == 1 ) {
1508   2                      outputSevenSeg('3');
1509   2              }
1510   1              else if ( keypad.k4 == 1 ) {
1511   2                      outputSevenSeg('4');
1512   2              }
1513   1              else if ( keypad.k5 == 1 ) {
1514   2                      outputSevenSeg('5');
1515   2              }
1516   1              else if ( keypad.k6 == 1 ) {
1517   2                      outputSevenSeg('6');
1518   2              }
1519   1              else if ( keypad.k7 == 1 ) {
1520   2                      outputSevenSeg('7');
1521   2              }
1522   1              else if ( keypad.k8 == 1 ) {
1523   2                      outputSevenSeg('8');
1524   2              }
1525   1              else if ( keypad.k9 == 1 ) {
1526   2                      outputSevenSeg('9');
1527   2              }
1528   1              else if ( keypad.kA == 1 ) {
1529   2                      outputSevenSeg('A');
1530   2              }
1531   1              else if ( keypad.k0 == 1 ) {
1532   2                      outputSevenSeg('0');
1533   2              }
1534   1              else if ( keypad.kB == 1 ) {
1535   2                      outputSevenSeg('b');
1536   2              }
1537   1              else if ( keypad.kC == 1 ) {
1538   2                      outputSevenSeg('C');
1539   2              }
1540   1              else if ( keypad.kD == 1 ) {
1541   2                      outputSevenSeg('d');
1542   2              }
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 26  

1543   1              else if ( keypad.kstar == 1 ) {
1544   2                      outputSevenSeg('.');
1545   2              }
1546   1              else if ( keypad.kpound == 1 ) {
1547   2                      outputSevenSeg('-');
1548   2              }
1549   1              else {
1550   2                      outputSevenSeg('o');
1551   2              }
1552   1              
1553   1      } // end displayKeyPressed()
1554                  
1555          // -------------------------------------------------------------- //
1556          
1557          void lcdCmd( byte cmd ) {
1558   1              
1559   1              //rs_lcd = 0;                   // reg select low for command
1560   1              // --- RW tied low for write --- //
1561   1              //e_lcd = 1;                    // E high for pulse
1562   1              
1563   1              missionControl1( ctrl_lcd_cmd_start );
1564   1              
1565   1              lcdPort = cmd;
1566   1              //latchLCD();
1567   1              
1568   1              msDelay(1);                     // Need Tpw > 140 ns
1569   1              //e_lcd = 0;                    // E low to end pulse
1570   1              
1571   1              missionControl1( ctrl_lcd_cmd_finish );
1572   1              
1573   1      } // end lcdCmd()
1574          
1575          // -------------------------------------------------------------- //
1576          
1577          void lcdData( byte dat ) {
1578   1              
1579   1              //rs_lcd = 1;                   // reg select high for data
1580   1              // --- RW tied low for write --- //
1581   1              //e_lcd = 1;                    // E high for pulse
1582   1              
1583   1              missionControl1( ctrl_lcd_data_start );
1584   1              
1585   1              lcdPort = dat;
1586   1              //latchLCD();
1587   1              
1588   1              msDelay(1);                     // Need Tpw > 140 ns
1589   1              //e_lcd = 0;                    // E low to end pulse
1590   1              
1591   1              missionControl1( ctrl_lcd_data_finish );
1592   1              
1593   1      } // end lcdData()
1594          
1595          // -------------------------------------------------------------- //
1596          
1597          void lcdInit( void ) {  
1598   1              
1599   1              msDelay(50);
1600   1              lcdCmd(0x38);                   // Function set
1601   1              msDelay(5);
1602   1              lcdCmd(0x38);                   // Function set
1603   1              msDelay(1);
1604   1              lcdCmd(0x0F);                   // Display ON/OFF control
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 27  

1605   1              msDelay(1);
1606   1              lcdCmd(0x01);                   // Clear display
1607   1              msDelay(2);
1608   1              
1609   1      } // end lcdInit()
1610          
1611          // -------------------------------------------------------------- //
1612          
1613          void lcdClear( void ) {
1614   1              
1615   1              lcdCmd(0x01);                   // Clear display
1616   1              msDelay(2);
1617   1              
1618   1      } // end lcdClear()
1619          
1620          // -------------------------------------------------------------- //
1621          
1622          void lcdChar( byte character ) {
1623   1              
1624   1              lcdData(character);             // send character
1625   1              
1626   1      } // end lcdChar()
1627          
1628          // -------------------------------------------------------------- //
1629          
1630          void lcdString( volatile char *string ) {
1631   1              
1632   1              int i = 0;
1633   1              while( string[i] != '`') {
1634   2                      lcdChar( string[i] );
1635   2                      i++;
1636   2              }
1637   1              
1638   1      } // end lcdString()
1639          
1640          // -------------------------------------------------------------- //
1641          
1642          void lcdLine( int line ) {
1643   1              
1644   1              switch (line) {
1645   2                      case 1: {
1646   3                              lcdCmd(0x80);
1647   3                              break;
1648   3                      }
1649   2                      case 2: {
1650   3                              lcdCmd(0xC0);
1651   3                              break;
1652   3                      }
1653   2                      case 3: {
1654   3                              lcdCmd(0x94);
1655   3                              break;
1656   3                      }
1657   2                      case 4: {
1658   3                              lcdCmd(0xD4);
1659   3                              break;
1660   3                      }
1661   2                      default:
1662   2                              lcdCmd(0x80);
1663   2                      
1664   2              } // end switch
1665   1              
1666   1      } // end lcdLine()
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 28  

1667          
1668          // -------------------------------------------------------------- //
1669          
1670          void lcdHexWord( word hex ) {
1671   1      
1672   1              char hexStr[] = "--------`";
1673   1      
1674   1              sprintf( hexStr, "%04X`", (int)hex );
1675   1              lcdString( &hexStr );
1676   1      
1677   1      } // end lcdHexWord()
1678          
1679          // -------------------------------------------------------------- //
1680          
1681          void lcdHexByte( byte hex ) {
1682   1      
1683   1              char hexStr[] = "-----`";
1684   1      
1685   1              sprintf( hexStr, "%02X`", (int)hex );
1686   1              lcdString( &hexStr );
1687   1      
1688   1      } // end lcdHexWord()
1689          
1690          // -------------------------------------------------------------- //
1691          
1692          void lcdAsciiByte( byte hex ) {
1693   1      
1694   1      //      char hexStr[] = "-----`";
1695   1      //
1696   1      //      sprintf( hexStr, "%1c`", (int)hex );
1697   1      //      lcdString( &hexStr );
1698   1      
1699   1              lcdChar( hex );
1700   1      
1701   1      } // end lcdHexWord()
1702          
1703          // -------------------------------------------------------------- //
1704          
1705          float getTemp( void ) {
1706   1              
1707   1              //------------ IDEA ------------------------------------------//
1708   1              // change to pass in C or F and returns corresponding value.  //
1709   1              
1710   1              int i = 0;
1711   1              byte sample = 0;
1712   1              float voltage = 0;
1713   1              float degC = 0;
1714   1              float degF = 0;
1715   1              int degCint = 0;
1716   1      //      char tempCStr[] = "+00.0 C`";
1717   1      //      char tempFStr[] = "+00.0 F`";
1718   1      //      char voltStr[] = "+0.0 V`";
1719   1      //      char sampStr[] = "55555555`";
1720   1              
1721   1                      missionControl2( ctrl_adc_start );
1722   1                      missionControl2( ctrl_adc_finish );
1723   1                      sample = adcPort;
1724   1                      missionControl2( ctrl_off );
1725   1                      
1726   1                      // voltage reading in 0.3V higher than measured on board
1727   1                      voltage = sample * 5 / 256;
1728   1                      //voltage = voltage - 0.25;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 29  

1729   1                      degC = (voltage - 0.5) * 100;
1730   1                      degF = degC * (9.0/5.0) + 32.0;
1731   1                      
1732   1                      return degF;
1733   1                      
1734   1      //              sprintf( sampStr, "%c`", sample );
1735   1      //              sprintf( voltStr, "%+4.1f V`", voltage );
1736   1      //              sprintf( tempCStr, "%+5.1f C`", degC );
1737   1      //              sprintf( tempFStr, "%+5.1f F`", degF );
1738   1                      
1739   1      //              lcdLine(1);
1740   1      //              lcdString( &sampStr );
1741   1      //              lcdLine(2);
1742   1      //              lcdString( &voltStr );
1743   1      //              lcdLine(3);
1744   1      //              lcdString( &tempCStr );
1745   1      //              lcdLine(4);
1746   1      //              lcdString( &tempFStr );
1747   1              
1748   1      } // end getDegF()
1749          
1750          // -------------------------------------------------------------- //
1751          
1752          void rtcInit( void ) {
1753   1              
1754   1              struct time_data time;
1755   1      
1756   1              time.week = 0;
1757   1              time.years = 17;
1758   1              time.months = 3;
1759   1              time.days = 26;
1760   1              time.hours = 12;
1761   1              time.minutes = 21;
1762   1              time.seconds = 0;
1763   1                      
1764   1              // (A)  Start the counter
1765   1              //                      Inititalize the control registers
1766   1              rtcWrite( 0xF4 );               // Set the CF register to 0100b = 4h
1767   1              rtcWrite( 0xD4 );               // Set the CD register to 0100b = 4h
1768   1              
1769   1              // (B)  Check the status of the BUSY bit
1770   1              rtcBusy();      
1771   1              
1772   1              // (C)  STOP and RESET the counter
1773   1              rtcWrite( 0xF7 );               // Set the CF register to 0111b = 7h
1774   1              
1775   1              // Set the current time in the registers
1776   1              //              (initizlize the S1 to W registers)
1777   1              rtcSetTime( time ); 
1778   1              
1779   1              // (A)  Start the counter and release the HOLD status
1780   1              rtcWrite( 0xF4 );               // Set the CF register to 0100b = 4h
1781   1              rtcWrite( 0xD5 );               // Set the CD register to 0101b = 5h
1782   1              
1783   1      } // end rtcInit()
1784          
1785          // -------------------------------------------------------------- //
1786          
1787          void rtcBusy( void ) {
1788   1              
1789   1              byte duhdata;
1790   1              
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 30  

1791   1              rtcWrite( 0xD5 );                                               // Hold bit <- 1
1792   1              duhdata = rtcRead( 0x0D );      // Read from D to get BUSY// Read the BUSY bit
1793   1      
1794   1              // If BUSY bit = 0, cont., else HOLD bit <- 0
1795   1              while( duhdata & 0x02 == 2 ) {
1796   2                      rtcWrite( 0xD4 );                                               // HOLD bit <- 0
1797   2                      rtcWrite( 0xD5 );                                               // HOLD bit <- 1
1798   2                      duhdata = rtcRead( 0x0D );      // Read from D to get BUSY// Read the BUSY bit
1799   2              }       
1800   1              
1801   1      } // end rtcBusy()
1802          
1803          // -------------------------------------------------------------- //
1804          
1805          void rtcWrite( byte duhdata ) {
1806   1              
1807   1              missionControl2( ctrl_rtc_cs1 );        // set CS1 high
1808   1              rtcPort = duhdata;                                      // send duhdata
1809   1              missionControl2( ctrl_rtc_cs0 );        // set CS0 low
1810   1              missionControl2( ctrl_rtc_wr );         // set WR low
1811   1              missionControl2( ctrl_rtc_cs0 );        // set WR high
1812   1              missionControl2( ctrl_rtc_cs1 );        // set CS0 high
1813   1              missionControl2( ctrl_off );            // set CS1 low
1814   1              
1815   1      } // end rtcWrite()
1816          
1817          // -------------------------------------------------------------- //
1818          
1819          byte rtcRead( byte duhaddress ) {
1820   1              
1821   1              byte duhdata = 0x00;
1822   1              
1823   1              duhaddress = duhaddress << 4;
1824   1              duhaddress = duhaddress | 0x0F;
1825   1              
1826   1              missionControl2( ctrl_rtc_cs1 );        // set CS1 high
1827   1              rtcPort = duhaddress;                           // send duhaddress
1828   1              missionControl2( ctrl_rtc_cs0 );        // set CS0 low
1829   1              missionControl2( ctrl_rtc_rd );         // set RD low
1830   1              duhdata = rtcPort;                                      // read duhdata
1831   1              duhdata &= 0x0F;                                        // mask upper nibble of value read in
1832   1              missionControl2( ctrl_rtc_cs0 );        // set RD high
1833   1              missionControl2( ctrl_rtc_cs1 );        // set CS0 high
1834   1              missionControl2( ctrl_off );            // set CS1 low
1835   1              
1836   1              return duhdata;
1837   1              
1838   1      } // end rtcRead()
1839          
1840          // -------------------------------------------------------------- //
1841          
1842          void rtcRegWrite( byte duhstuff ) {
1843   1              
1844   1              rtcBusy();
1845   1              rtcWrite( duhstuff );
1846   1              // HOLD bit <- 0 by rtcWrite when CS1 is cleared
1847   1              
1848   1      } // end rtcRegWrite()
1849          
1850          // -------------------------------------------------------------- //
1851          
1852          byte rtcRegRead( byte duhstuff ) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 31  

1853   1              
1854   1              byte duhdata;
1855   1      
1856   1              rtcBusy();
1857   1              duhdata = rtcRead( duhstuff );
1858   1              // HOLD bit <- 0 by rtcWrite when CS1 is cleared
1859   1              return duhdata;
1860   1              
1861   1      } // end rtcRegWrite()
1862          
1863          // -------------------------------------------------------------- //
1864          
1865          void rtcSetTime( struct time_data time ) {
1866   1              
1867   1              byte s1, s10, mi1, mi10, h1, h10, d1, d10, mo1, mo10, y1, y10;
1868   1              
1869   1              // 1-second
1870   1              s1 = time.seconds % 10;
1871   1              rtcRegWrite( 0x00 | s1 );
1872   1              
1873   1              // 10-second
1874   1              s10 = time.seconds / 10;
1875   1              rtcRegWrite( 0x10 | s10 );
1876   1              
1877   1              // 1-minute
1878   1              mi1 = time.minutes % 10;
1879   1              rtcRegWrite( 0x20 | mi1 );
1880   1              
1881   1              // 10-minute
1882   1              mi10 = time.minutes / 10;
1883   1              rtcRegWrite( 0x30 | mi10 );
1884   1              
1885   1              // 1-hour
1886   1              h1 = time.hours % 10;
1887   1              rtcRegWrite( 0x40 | h1 );
1888   1              
1889   1              // 10-hour
1890   1              h10 = time.hours / 10;
1891   1              rtcRegWrite( 0x50 | h10 );
1892   1              
1893   1              // 1-day
1894   1              d1 = time.days % 10;
1895   1              rtcRegWrite( 0x60 | d1 );
1896   1              
1897   1              // 10-day
1898   1              d10 = time.days / 10;
1899   1              rtcRegWrite( 0x70 | d10 );
1900   1              
1901   1              // 1-month
1902   1              mo1 = time.months % 10;
1903   1              rtcRegWrite( 0x80 | mo1 );
1904   1              
1905   1              // 10-month
1906   1              mo10 = time.months / 10;
1907   1              rtcRegWrite( 0x90 | mo10 );
1908   1              
1909   1              // 1-year
1910   1              y1 = time.years % 10;
1911   1              rtcRegWrite( 0xA0 | y1 );
1912   1              
1913   1              // 10-year
1914   1              y10 = time.years / 10;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 32  

1915   1              rtcRegWrite( 0xB0 | y10 );
1916   1              
1917   1              // Day of the week
1918   1              rtcRegWrite( 0xC0 | time.week );
1919   1              
1920   1      } // end rtcSetTime()
1921          
1922          // -------------------------------------------------------------- //
1923          
1924          struct time_data rtcGetTime( void ) {
1925   1              
1926   1              struct time_data time;
1927   1              byte s1, s10, mi1, mi10, h1, h10, d1, d10, mo1, mo10, y1, y10, w;
1928   1              
1929   1              s1 = rtcRegRead( 0x00 );
1930   1              s10 = rtcRegRead( 0x01 );
1931   1              time.seconds = s1 + ( s10 * 10 );
1932   1      
1933   1              mi1 = rtcRegRead( 0x02 );
1934   1              mi10 = rtcRegRead( 0x03 );
1935   1              time.minutes = mi1 + ( mi10 * 10 );
1936   1      
1937   1              h1 = rtcRegRead( 0x04 );
1938   1              h10 = rtcRegRead( 0x05 );
1939   1              time.hours = h1 + ( h10 * 10 );
1940   1      
1941   1              d1 = rtcRegRead( 0x06 );
1942   1              d10 = rtcRegRead( 0x07 );
1943   1              time.days = d1 + ( d10 * 10 );
1944   1      
1945   1              mo1 = rtcRegRead( 0x08 );
1946   1              mo10 = rtcRegRead( 0x09 );
1947   1              time.months = mo1 + ( mo10 * 10 );
1948   1      
1949   1              y1 = rtcRegRead( 0x0A );
1950   1              y10 = rtcRegRead( 0x0B );
1951   1              time.years = y1 + ( y10 * 10 );
1952   1      
1953   1              w = rtcRegRead( 0x0C );
1954   1              time.week = w;
1955   1      
1956   1              return time;
1957   1              
1958   1      } // end rtcSetTime()
1959          
1960          // -------------------------------------------------------------- //
1961          
1962          void rtcPrintTime( struct time_data *time ) {
1963   1      
1964   1              char timeStr[] = "0 00/00/00 00:00:00`";
1965   1      
1966   1              sprintf( timeStr, "%d %02d/%02d/%02d %02d:%02d:%02d`", 
1967   1                              (int)time->week, 
1968   1                              (int)time->months, (int)time->days, (int)time->years, 
1969   1                              (int)time->hours, (int)time->minutes, (int)time->seconds );
1970   1              lcdString( &timeStr );
1971   1      
1972   1      } // end rtcPrintTime()
1973          
1974          // -------------------------------------------------------------- //
1975          
1976          void missionControl1( int dec ) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 33  

1977   1              
1978   1              switch ( dec ) {
1979   2                      
1980   2                      // The MSB is changed first to avoid false triggers of the LCD enable
1981   2                      // line as the enable line never goes high when the MSB is low.
1982   2                      case ctrl_off: {
1983   3                              dec2 = 0;
1984   3                              dec1 = 0;
1985   3                              dec0 = 0;
1986   3                              break;
1987   3                      }
1988   2                      case ctrl_ss_latch: {
1989   3                              dec2 = 0;
1990   3                              dec1 = 0;
1991   3                              dec0 = 1;
1992   3                              break;
1993   3                      }
1994   2                      case ctrl_kp_oe: {
1995   3                              dec2 = 0;
1996   3                              dec1 = 1;
1997   3                              dec0 = 0;
1998   3                              break;
1999   3                      }
2000   2                      case ctrl_kp_oelatch: {
2001   3                              dec2 = 0;
2002   3                              dec1 = 1;
2003   3                              dec0 = 1;
2004   3                              break;
2005   3                      }
2006   2                      case ctrl_lcd_cmd_start: {
2007   3                              dec2 = 1;
2008   3                              dec1 = 0;
2009   3                              dec0 = 0;
2010   3                              break;
2011   3                      }
2012   2                      case ctrl_lcd_cmd_finish: {
2013   3                              dec2 = 1;
2014   3                              dec1 = 0;
2015   3                              dec0 = 1;
2016   3                              break;
2017   3                      }
2018   2                      case ctrl_lcd_data_start: {
2019   3                              dec2 = 1;
2020   3                              dec1 = 1;
2021   3                              dec0 = 0;
2022   3                              break;
2023   3                      }
2024   2                      case ctrl_lcd_data_finish: {
2025   3                              dec2 = 1;
2026   3                              dec1 = 1;
2027   3                              dec0 = 1;
2028   3                              break;
2029   3                      }               
2030   2              } // end switch
2031   1              
2032   1      } // end missionControl1()
2033          
2034          // -------------------------------------------------------------- //
2035          
2036          void missionControl2( int dec ) {
2037   1              
2038   1              switch ( dec ) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 34  

2039   2                      case ctrl_off: {
2040   3                              dec4 = 0;
2041   3                              dec3 = 0;
2042   3                              dec5 = 0;
2043   3                              break;
2044   3                      }
2045   2                      case ctrl_adc_start: {
2046   3                              dec4 = 0;
2047   3                              dec3 = 1;
2048   3                              dec5 = 0;
2049   3                              break;
2050   3                      }
2051   2                      case ctrl_rtc_rd: {
2052   3                              dec4 = 1;
2053   3                              dec3 = 0;
2054   3                              dec5 = 0;
2055   3                              break;
2056   3                      }
2057   2                      case ctrl_adc_finish: {
2058   3                              dec4 = 1;
2059   3                              dec3 = 1;
2060   3                              dec5 = 0;
2061   3                              break;
2062   3                      }
2063   2                      case ctrl_rtc_cs1: {
2064   3                              dec4 = 0;
2065   3                              dec3 = 0;
2066   3                              dec5 = 1;
2067   3                              break;
2068   3                      }
2069   2                      // not used
2070   2      //              case ctrl_rtc_cs0: {
2071   2      //                      dec5 = 1;
2072   2      //                      dec4 = 0;
2073   2      //                      dec3 = 1;
2074   2      //                      break;
2075   2      //              }
2076   2                      case ctrl_rtc_cs0: {
2077   3                              dec4 = 1;
2078   3                              dec3 = 0;
2079   3                              dec5 = 1;
2080   3                              break;
2081   3                      }
2082   2                      case ctrl_rtc_wr: {
2083   3                              dec4 = 1;
2084   3                              dec3 = 1;
2085   3                              dec5 = 1;
2086   3                              break;
2087   3                      }               
2088   2              } // end switch
2089   1              
2090   1      } // end missionControl2()
2091          
2092          // -------------------------------------------------------------- //
2093          
2094          void msDelay( unsigned msecs ) {
2095   1              
2096   1              unsigned i;
2097   1              unsigned char j;
2098   1              
2099   1              msecs = msecs * 3.23;
2100   1              
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/02/2017 12:29:16 PAGE 35  

2101   1              for(i=0;i<msecs;i++){
2102   2                      for(j=0;j<100;j++);
2103   2              }
2104   1              
2105   1      } // end msDelay()
2106          
2107          // -------------------------------------------------------------- //
2108          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6982    ----
   CONSTANT SIZE    =    888    ----
   XDATA SIZE       =   ----    1227
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
