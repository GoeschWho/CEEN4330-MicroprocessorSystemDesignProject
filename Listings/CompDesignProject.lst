C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE COMPDESIGNPROJECT
OBJECT MODULE PLACED IN .\Objects\CompDesignProject.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE CompDesignProject.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\CompDe
                    -signProject.lst) OBJECT(.\Objects\CompDesignProject.obj)

line level    source

   1          /* Auth: Megan Bird
   2           * File: CompDesignProject.c
   3           * Course: CEEN-4330 – Microprocessor System Design – University of Nebraska-Lincoln
   4           * Lab: Project
   5           * Date: 3/14/2017
   6           * Desc: 8051 program with ROM, RAM, and I/O
   7           */
   8           
   9          #include <REGX55.H>
  10          #include <stdio.h>
  11          #include <absacc.h>
  12          
  13          // P1
  14          sbit P1_0 = P1^0;
  15          sbit P1_1 = P1^1;
  16          
  17          // P3
  18          sbit P3_0 = P3^0;
  19          sbit P3_1 = P3^1;
  20          sbit P3_2 = P3^2;
  21          sbit P3_3 = P3^3;
  22          sbit P3_4 = P3^4;
  23          sbit P3_5 = P3^5;
  24          sbit P3_6 = P3^6;
  25          sbit P3_7 = P3^7;
  26          
  27          // Keypad
  28          sbit kCol1  = P1^7;
  29          sbit kCol2  = P1^6;
  30          sbit kCol3  = P1^5;
  31          sbit kCol4  = P1^4;
  32          sbit kRow1  = P1^3;
  33          sbit kRow2  = P1^2;
  34          sbit kRow3  = P1^1;
  35          sbit kRow4  = P1^0;
  36          sbit cs_keypad = P3^1;          // latch
  37          sbit oe_keypad = P3^2;
  38          
  39          // Seven-Segment Display
  40          sfr sevenSegPort = 0x90;
  41          sbit cs_sevenSeg = P3^0;        // latch
  42          
  43          // LCD
  44          sbit cs_lcd = P3^3;                             // latch
  45          sbit rs_lcd = P3^4;                             // reg select
  46          sbit e_lcd  = P3^5;                             // enable
  47          // rw tied to ground to always enable read
  48          sfr lcdPort = 0x90;
  49          
  50          // ADC
  51          sbit oe_adc = P3^3;                             // latch output enable
  52          sbit wr_adc = P3^4;                             // WR line of ADC
  53          sfr adcPort = 0x90;
  54          
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 2   

  55          // RTC
  56          sbit rtc_data0 = P1^0;
  57          sbit rtc_data1 = P1^1;
  58          sbit rtc_data2 = P1^2;
  59          sbit rtc_data3 = P1^3;
  60          sbit rtc_add0 = P1^4;
  61          sbit rtc_add1 = P1^5;
  62          sbit rtc_add2 = P1^6;
  63          sbit rtc_add3 = P1^7;
  64          sfr rtcPort = 0x90;
  65          
  66          // Mission Control 1
  67          enum {ctrl_off,
  68                                  ctrl_ss_latch,
  69                                  ctrl_kp_oe,
  70                                  ctrl_kp_oelatch,
  71                                  ctrl_lcd_cmd_start,
  72                                  ctrl_lcd_cmd_finish,
  73                                  ctrl_lcd_data_start,
  74                                  ctrl_lcd_data_finish };
  75          
  76          // Mission Control 2
  77          enum {ctrl_adc_start = 1,
  78                                  ctrl_rtc_rd,
  79                                  ctrl_adc_finish,
  80                                  ctrl_rtc_cs1,
  81                                  ctrl_rtc_cs0 = 6,
  82                                  ctrl_rtc_wr };
  83          
  84          sbit dec0 = P3^0;
  85          sbit dec1 = P3^1;               
  86          sbit dec2 = P3^2;
  87          sbit dec3 = P3^3;
  88          sbit dec4 = P3^4;
  89          sbit dec5 = P3^5;
  90          
  91          // ======================= prototypes =========================== //
  92          
  93          typedef unsigned char byte;
  94          typedef unsigned short word;
  95          typedef enum { false, true } bool;
  96          
  97          struct keypad_data {
  98                  bool k1;
  99                  bool k2;
 100                  bool k3;
 101                  bool k4;
 102                  bool k5;
 103                  bool k6;
 104                  bool k7;
 105                  bool k8;
 106                  bool k9;
 107                  bool k0;
 108                  bool kA;
 109                  bool kB;
 110                  bool kC;
 111                  bool kD;
 112                  bool kstar;
 113                  bool kpound;
 114          };
 115          
 116          struct time_data {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 3   

 117                  byte seconds;
 118                  byte minutes;
 119                  byte hours;
 120                  byte days;
 121                  byte months;
 122                  byte years;
 123                  byte week;
 124          };
 125          
 126          //------- high level prototyeps -------//
 127          void mainMenu( void );
 128          void memoryMenu( void );
 129          void ioMenu( void );
 130          void dumpMenu( void );
 131          void moveMenu( void );
 132          void editMenu( void );
 133          void findMenu( void );
 134          void tempMenu( void );
 135          void sevenSegMenu( void );
 136          void timeMenu( void );
 137          void stopwatchMenu( void );
 138          
 139          word input4Hex( void );
 140          byte input2Hex( void );
 141          word inputHex( void );
 142          void waitForKeyRelease( void );
 143          
 144          //------- low level prototypes -------//
 145          void latchSevenSeg( void );
 146          void latchKeypad( void );
 147          void outputSevenSeg( char character );
 148          struct keypad_data getKeysPressed( void );
 149          void displayKeyPressed( struct keypad_data keypad );
 150          
 151          void lcdCmd( byte cmd );
 152          void lcdData( byte dat );
 153          void lcdInit( void );
 154          void lcdClear( void );
 155          void lcdChar( byte character );
 156          void lcdString( volatile char *string );
 157          void lcdLine( int line );
 158          void lcdHexWord( word hex );
 159          void lcdHexByte( byte hex );
 160          void lcdAsciiByte( byte hex );
 161          
 162          float getTemp( void );
 163          
 164          void rtcInit( void );
 165          void rtcBusy( void );
 166          void rtcWrite( byte duhdata );
 167          byte rtcRead( byte duhaddress );
 168          void rtcRegWrite( byte duhstuff );
 169          byte rtcRegRead( byte duhstuff );
 170          void rtcSetTime( struct time_data time );
 171          struct time_data rtcGetTime( void );
 172          void rtcPrintTime( struct time_data *time );
 173          
 174          void missionControl1( int dec );
 175          void missionControl2( int dec );
 176          void msDelay( unsigned msecs );
 177          
 178          // ======================== main ================================ //
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 4   

 179          
 180          void main(void) {
 181   1              
 182   1              missionControl1( ctrl_off );
 183   1              missionControl2( ctrl_off );
 184   1              
 185   1              lcdInit();
 186   1              rtcInit();
 187   1      
 188   1              mainMenu();             // Enter main program
 189   1      
 190   1              while(1); // Stay off the streets
 191   1      
 192   1      } // end main()
 193          
 194          // ======================= functions ============================ //
 195          
 196          void mainMenu( void ) { 
 197   1      
 198   1              struct keypad_data keypad;
 199   1      
 200   1              while(1) {
 201   2      
 202   2                      char MenuStr1[] = "Megan Bird CEEN 4330`";
 203   2                      char MenuStr2[] = "--------------------`";
 204   2                      char MenuStr3[] = "Main Menu`";
 205   2                      char MenuStr4[] = "1 : Memory   2 : I/O`";
 206   2              
 207   2                      lcdClear();
 208   2                      lcdString( &MenuStr1 );
 209   2                      lcdLine(2);
 210   2                      lcdString( &MenuStr2 );
 211   2                      lcdLine(3);
 212   2                      lcdString( &MenuStr3 );
 213   2                      lcdLine(4);
 214   2                      lcdString( &MenuStr4 );
 215   2              
 216   2                      while(1) {      
 217   3                              keypad = getKeysPressed();
 218   3                      
 219   3                              if( keypad.k1 == true ) {
 220   4                                      waitForKeyRelease();
 221   4                                      memoryMenu();
 222   4                                      break;
 223   4                              }
 224   3                              else if( keypad.k2 == true ) {
 225   4                                      waitForKeyRelease();
 226   4                                      ioMenu();
 227   4                                      break;
 228   4                              }
 229   3                      } // end option while
 230   2      
 231   2              } // end main while
 232   1      
 233   1      } // end choiceMainMenu()
 234          
 235          // -------------------------------------------------------------- //
 236          
 237          void memoryMenu( void ) {
 238   1      
 239   1              struct keypad_data keypad;
 240   1              bool exit = false;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 5   

 241   1      
 242   1              while( exit == false ) {
 243   2      
 244   2                      char MenuStr1[] = "Memory Menu`";
 245   2                      char MenuStr2[] = "1 : Dump    2 : Move`";
 246   2                      char MenuStr3[] = "3 : Edit    4 : Find`";
 247   2                      char MenuStr4[] = "# : Return to Main  `";
 248   2              
 249   2                      lcdClear();
 250   2                      lcdString( &MenuStr1 );
 251   2                      lcdLine(2);
 252   2                      lcdString( &MenuStr2 );
 253   2                      lcdLine(3);
 254   2                      lcdString( &MenuStr3 );
 255   2                      lcdLine(4);
 256   2                      lcdString( &MenuStr4 );
 257   2              
 258   2                      while(1) {      
 259   3                              keypad = getKeysPressed();
 260   3                      
 261   3                              if( keypad.kpound == true ) {
 262   4                                      exit = true;
 263   4                                      waitForKeyRelease();
 264   4                                      break;
 265   4                              }
 266   3                              else if( keypad.k1 == true ) {
 267   4                                      waitForKeyRelease();
 268   4                                      dumpMenu();
 269   4                                      break;
 270   4                              }
 271   3                              else if( keypad.k2 == true ) {
 272   4                                      waitForKeyRelease();
 273   4                                      moveMenu();
 274   4                                      break;
 275   4                              }
 276   3                              else if( keypad.k3 == true ) {
 277   4                                      waitForKeyRelease();
 278   4                                      editMenu();
 279   4                                      break;
 280   4                              }
 281   3                              else if( keypad.k4 == true ) {
 282   4                                      waitForKeyRelease();
 283   4                                      findMenu();
 284   4                                      break;
 285   4                              }
 286   3                      } // end option while
 287   2      
 288   2              } // end main while
 289   1      
 290   1      } // end memoryMenu()
 291          
 292          // -------------------------------------------------------------- //
 293          
 294          void ioMenu( void ) {
 295   1      
 296   1              struct keypad_data keypad;
 297   1              bool exit = false;
 298   1      
 299   1              while( exit == false ) {
 300   2      
 301   2                      char MenuStr1[] = "I/O Menu`";
 302   2                      char MenuStr2[] = "1 : Temp   2 : 7-Seg`";
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 6   

 303   2                      char MenuStr3[] = "3 : Time   4 : StopW`";
 304   2                      char MenuStr4[] = "# : Return to Main  `";
 305   2              
 306   2                      lcdClear();
 307   2                      lcdString( &MenuStr1 );
 308   2                      lcdLine(2);
 309   2                      lcdString( &MenuStr2 );
 310   2                      lcdLine(3);
 311   2                      lcdString( &MenuStr3 );
 312   2                      lcdLine(4);
 313   2                      lcdString( &MenuStr4 );
 314   2              
 315   2                      while(1) {      
 316   3                              keypad = getKeysPressed();
 317   3                      
 318   3                              if( keypad.kpound == true ) {
 319   4                                      exit = true;
 320   4                                      waitForKeyRelease();
 321   4                                      break;
 322   4                              }
 323   3                              else if( keypad.k1 == true ) {
 324   4                                      waitForKeyRelease();
 325   4                                      tempMenu();
 326   4                                      break;
 327   4                              }
 328   3                              else if( keypad.k2 == true ) {
 329   4                                      waitForKeyRelease();
 330   4                                      sevenSegMenu();
 331   4                                      break;
 332   4                              }
 333   3                              else if( keypad.k3 == true ) {
 334   4                                      waitForKeyRelease();
 335   4                                      timeMenu();
 336   4                                      break;
 337   4                              }
 338   3                              else if( keypad.k4 == true ) {
 339   4                                      waitForKeyRelease();
 340   4                                      stopwatchMenu();
 341   4                                      break;
 342   4                              }
 343   3                      } // end option while
 344   2      
 345   2              } // end main while
 346   1      
 347   1      } // end ioMenu()
 348          
 349          // -------------------------------------------------------------- //
 350          
 351          void dumpMenu( void ) {
 352   1      
 353   1              struct keypad_data keypad;
 354   1              bool exit;
 355   1              word segment;
 356   1              word block;
 357   1              word offset;
 358   1              byte memVal;
 359   1              int i;
 360   1              
 361   1              char MenuStr1[] = "Dump Setup`";
 362   1              char MenuStr2[] = "Start Seg Addr: `";
 363   1              char MenuStr3[] = "Block Size: `";
 364   1              char MenuStr4[] = "1:<--  2:-->  #:Exit`";
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 7   

 365   1      
 366   1              exit = false;
 367   1              segment = 0x0000;
 368   1              block = 0x0000;
 369   1              offset = 0x0000;
 370   1      
 371   1              //----------------//
 372   1              //   Dump Setup   //
 373   1              //----------------//
 374   1      
 375   1              // print header and footer
 376   1              lcdClear();
 377   1              lcdString( &MenuStr1 );
 378   1      
 379   1              // address prompt
 380   1              lcdLine(3);
 381   1              lcdString( &MenuStr2 );
 382   1              // read 4 hex digits from keypad
 383   1              segment = input4Hex(); 
 384   1      
 385   1              // block size prompt
 386   1              lcdLine(4);
 387   1              lcdString( &MenuStr3 );
 388   1              // read 4 hex digits from keypad
 389   1              while( block == 0x0000 ) {
 390   2                      block = input4Hex();
 391   2              }
 392   1      
 393   1              //------------------//
 394   1              //   Dump Display   //
 395   1              //------------------//
 396   1      
 397   1              while( exit == false ) {
 398   2      
 399   2                      // print segment:offset
 400   2                      lcdClear();
 401   2                      lcdHexWord( segment );
 402   2                      lcdChar(':');
 403   2                      lcdHexWord( offset );
 404   2      
 405   2                      // print hex values
 406   2                      lcdLine(2);
 407   2                      for( i = 0; i < 7; i++ ) {
 408   3                              if( (offset + i) < block ) {
 409   4                                      memVal = XBYTE[ (segment * 16) + offset + i ]; // get seg:offset+i
 410   4                                      lcdHexByte( memVal );   // print value
 411   4                                      if( i < 6 ) {
 412   5                                              lcdChar(' ');           // print space if not last one on line
 413   5                                      }
 414   4                              }
 415   3                      }
 416   2      
 417   2                      // print ascii values
 418   2                      lcdLine(3);
 419   2                      for( i = 0; i < 7; i++ ) {
 420   3                              if( (offset + i) < block ) {
 421   4                                      memVal = XBYTE[ (segment * 16) + offset + i ]; // get seg:offset+i
 422   4                                      lcdAsciiByte( memVal ); // print value
 423   4                                      lcdChar(' ');
 424   4                                      if( i < 6 ) {
 425   5                                              lcdChar(' ');           // print space if not last one on line
 426   5                                      }
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 8   

 427   4                              }
 428   3                      }
 429   2      
 430   2                      // print footer
 431   2                      lcdLine(4);
 432   2                      lcdString( &MenuStr4 );         
 433   2                              
 434   2                      while(1) {      
 435   3                              keypad = getKeysPressed();
 436   3                      
 437   3                              if( keypad.kpound == true ) {
 438   4                                      exit = true;
 439   4                                      waitForKeyRelease();
 440   4                                      break;
 441   4                              }
 442   3                              else if( keypad.k1 == true ) {
 443   4                                      waitForKeyRelease();
 444   4                                      // if decremented offset is less than start (0),
 445   4                                      if( offset >= 7 ) {
 446   5                                              //      revert (-7) and do nothing
 447   5                                              offset -= 7;
 448   5                                      }
 449   4                                      break;
 450   4                              }
 451   3                              else if( keypad.k2 == true ) {
 452   4                                      waitForKeyRelease();
 453   4                                      // increment offset by 7
 454   4                                      offset += 7;
 455   4                                      // if incremented offset is past block size,
 456   4                                      if( offset > block ) {
 457   5                                              //      revert (-7) and do nothing
 458   5                                              offset -= 7;
 459   5                                      }
 460   4                                      break;
 461   4                              }
 462   3                      } // end option while
 463   2      
 464   2              } // end main while
 465   1      
 466   1      } // end dumpMenu()
 467          
 468          // -------------------------------------------------------------- //
 469          
 470          void moveMenu( void ) {
 471   1      
 472   1              struct keypad_data keypad;
 473   1              bool exit;
 474   1              word sourceSegment;
 475   1              word destSegment;
 476   1              word block;
 477   1              word offset;
 478   1              byte memVal;
 479   1              int i;
 480   1              
 481   1              char MenuStr1[] = "Move Setup`";
 482   1              char MenuStr2[] = "Source Seg Addr: `";
 483   1              char MenuStr3[] = "Dest Seg Addr: `";
 484   1              char MenuStr4[] = "Block Size: `";
 485   1              char MenuStr5[] = "Move Complete`";
 486   1              char MenuStr6[] = "#:Exit`";
 487   1      
 488   1              exit = false;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 9   

 489   1              sourceSegment = 0x0000;
 490   1              destSegment = 0x0000;
 491   1              block = 0x0000;
 492   1              offset = 0x0000;
 493   1              i = 0;
 494   1      
 495   1              //----------------//
 496   1              //   Move Setup   //
 497   1              //----------------//
 498   1      
 499   1              // print header and footer
 500   1              lcdClear();
 501   1              lcdString( &MenuStr1 );
 502   1      
 503   1              // source address prompt
 504   1              lcdLine(2);
 505   1              lcdString( &MenuStr2 );
 506   1              // read 4 hex digits from keypad
 507   1              sourceSegment = input4Hex(); 
 508   1      
 509   1              // dest address prompt
 510   1              lcdLine(3);
 511   1              lcdString( &MenuStr3 );
 512   1              // read 4 hex digits from keypad
 513   1              destSegment = input4Hex();
 514   1      
 515   1              // block size prompt
 516   1              lcdLine(4);
 517   1              lcdString( &MenuStr4 );
 518   1              // read 4 hex digits from keypad
 519   1              while( block == 0x0000 ) {
 520   2                      block = input4Hex();
 521   2              }
 522   1      
 523   1              //------------------//
 524   1              //   Move Display   //
 525   1              //------------------//
 526   1      
 527   1              while( exit == false ) {
 528   2      
 529   2                      // print segment:offset
 530   2                      lcdClear();
 531   2                      lcdString( &MenuStr5 );
 532   2                      lcdLine(4);
 533   2                      lcdString( &MenuStr6 );
 534   2      //              lcdHexWord( segment );
 535   2      //              lcdChar(':');
 536   2      //              lcdHexWord( offset );
 537   2                      
 538   2      
 539   2                      // perform move
 540   2                      while( (offset + i) < block ) {
 541   3                              memVal = XBYTE[ (sourceSegment * 16) + offset + i ]; // get sourceSeg:offset+i
 542   3                              XBYTE[ (destSegment * 16) + offset + i ] = memVal;      // move to destSeg:offset+i
 543   3                              i++;
 544   3                      }       
 545   2                              
 546   2                      while(1) {      
 547   3                              keypad = getKeysPressed();
 548   3                      
 549   3                              if( keypad.kpound == true ) {
 550   4                                      exit = true;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 10  

 551   4                                      waitForKeyRelease();
 552   4                                      break;
 553   4                              }
 554   3      
 555   3                      } // end option while
 556   2      
 557   2              } // end main while
 558   1      
 559   1      } // end moveMenu()
 560          
 561          // -------------------------------------------------------------- //
 562          
 563          void editMenu( void ) {
 564   1      
 565   1              struct keypad_data keypad;
 566   1              bool exit;
 567   1              bool next;
 568   1              word segment;
 569   1              word offset;
 570   1              byte new_value;
 571   1              byte memVal;
 572   1              
 573   1              char MenuStr1[] = "Edit Setup`";
 574   1              char MenuStr2[] = "Segment Addr: `";
 575   1              char MenuStr3[] = "Offset Addr: `";
 576   1              char MenuStr4[] = "New Value: `";
 577   1              char MenuStr5[] = "Edit Complete`";
 578   1              char MenuStr6[] = "0:Continue    #:Exit`";
 579   1      
 580   1              exit = false;
 581   1              next = true;
 582   1              segment = 0x0000;
 583   1              offset = 0x0000;
 584   1              new_value = 0xAA;
 585   1      
 586   1              //----------------//
 587   1              //   Edit Setup   //
 588   1              //----------------//
 589   1      
 590   1              // print header and footer
 591   1              lcdClear();
 592   1              lcdString( &MenuStr1 );
 593   1      
 594   1              // segment address prompt
 595   1              lcdLine(2);
 596   1              lcdString( &MenuStr2 );
 597   1              // read 4 hex digits from keypad
 598   1              segment = input4Hex(); 
 599   1      
 600   1              // offset address prompt
 601   1              lcdLine(3);
 602   1              lcdString( &MenuStr3 );
 603   1              // read 4 hex digits from keypad
 604   1              offset = input4Hex();
 605   1              
 606   1              //------------------//
 607   1              //   Edit Display   //
 608   1              //------------------//
 609   1      
 610   1              while( exit == false ) {
 611   2      
 612   2                      if( next == true ) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 11  

 613   3      
 614   3                              // print segment:offset
 615   3                              lcdClear();
 616   3                              lcdHexWord( segment );
 617   3                              lcdChar(':');
 618   3                              lcdHexWord( offset );
 619   3                              lcdChar(' ');
 620   3      
 621   3                              // print current value
 622   3                              memVal = XBYTE[ (segment * 16) + offset ]; // get seg:offset
 623   3                              lcdHexByte( memVal );   // print value
 624   3                      
 625   3                              // new value prompt
 626   3                              lcdLine(2);
 627   3                              lcdString( &MenuStr4 );
 628   3                      
 629   3                              // read 2 hex digits from keypad
 630   3                              new_value = input2Hex();
 631   3                              // store value
 632   3                              XBYTE[ (segment * 16) + offset ] = new_value;   // move to destSeg:offset
 633   3                      
 634   3                              // edit complete
 635   3                              lcdLine(3);
 636   3                              lcdString( &MenuStr5 );
 637   3                      
 638   3                              // exit prompt
 639   3                              lcdLine(4);
 640   3                              lcdString( &MenuStr6 );
 641   3      
 642   3                              offset++;
 643   3      
 644   3                      } // end next if
 645   2                              
 646   2                      while(1) {      
 647   3      
 648   3                              keypad = getKeysPressed();
 649   3                      
 650   3                              if( keypad.kpound == true ) {
 651   4                                      next = false;
 652   4                                      exit = true;
 653   4                                      waitForKeyRelease();
 654   4                                      break;
 655   4                              }
 656   3      
 657   3                              if( keypad.k0 == true ) {
 658   4                                      next = true;
 659   4                                      waitForKeyRelease();
 660   4                                      break;
 661   4                              }
 662   3      
 663   3                      } // end option while
 664   2      
 665   2              } // end main while
 666   1      
 667   1      } // end editMenu()
 668          
 669          // -------------------------------------------------------------- //
 670          
 671          void findMenu( void ) {
 672   1      
 673   1              struct keypad_data keypad;
 674   1              bool exit;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 12  

 675   1              bool found;
 676   1              word segment;
 677   1              word offset;
 678   1              word block;
 679   1              byte search_value;
 680   1              byte memVal;
 681   1              
 682   1              char MenuStr1[] = "Find Setup`";
 683   1              char MenuStr2[] = "Start Seg Addr: `";
 684   1              char MenuStr3[] = "Block Size: `";
 685   1              char MenuStr4[] = "Search Value: `";
 686   1              char MenuStr5[] = "Value found at`";
 687   1              char MenuStr6[] = "Value not found!`";
 688   1              char MenuStr7[] = "#:Exit`";
 689   1      
 690   1              exit = false;
 691   1              found = false;
 692   1              segment = 0x0000;
 693   1              offset = 0x0000;
 694   1              block = 0x0000;
 695   1              search_value = 0xAA;
 696   1      
 697   1              //----------------//
 698   1              //   Find Setup   //
 699   1              //----------------//
 700   1      
 701   1              // print header and footer
 702   1              lcdClear();
 703   1              lcdString( &MenuStr1 );
 704   1      
 705   1              // start address prompt
 706   1              lcdLine(2);
 707   1              lcdString( &MenuStr2 );
 708   1              // read 4 hex digits from keypad
 709   1              segment = input4Hex(); 
 710   1      
 711   1              // block size prompt
 712   1              lcdLine(3);
 713   1              lcdString( &MenuStr3 );
 714   1              // read 4 hex digits from keypad
 715   1              block = input4Hex();
 716   1      
 717   1              // search value prompt
 718   1              lcdLine(4);
 719   1              lcdString( &MenuStr4 );
 720   1              // read 4 hex digits from keypad
 721   1              search_value = input2Hex();
 722   1              
 723   1              //------------------//
 724   1              //   Find Display   //
 725   1              //------------------//
 726   1      
 727   1              // search block for value
 728   1              while( (offset) < block ) {
 729   2                      memVal = XBYTE[ (segment * 16) + offset ]; // get seg:offset+i
 730   2                      if( memVal == search_value ) {
 731   3                         found = true;
 732   3                         break;
 733   3                      }
 734   2                      offset++;
 735   2              }
 736   1      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 13  

 737   1              // print result
 738   1              lcdClear();
 739   1              if( found == true ) {
 740   2                      // Value found at ...
 741   2                      lcdString( &MenuStr5 );
 742   2                      // print segment:offset
 743   2                      lcdLine(2);
 744   2                      lcdHexWord( segment );
 745   2                      lcdChar(':');
 746   2                      lcdHexWord( offset );
 747   2                      // Footer
 748   2                      lcdLine(4);
 749   2                      lcdString( &MenuStr7 );
 750   2              }
 751   1              else {
 752   2                      // Value not found
 753   2                      lcdString( &MenuStr6 );
 754   2                      // Footer
 755   2                      lcdLine(4);
 756   2                      lcdString( &MenuStr7 );
 757   2              }
 758   1      
 759   1              while( exit == false ) {
 760   2                              
 761   2                      while(1) {      
 762   3      
 763   3                              keypad = getKeysPressed();
 764   3                      
 765   3                              if( keypad.kpound == true ) {
 766   4                                      exit = true;
 767   4                                      waitForKeyRelease();
 768   4                                      break;
 769   4                              }
 770   3      
 771   3                      } // end option while
 772   2      
 773   2              } // end main while
 774   1      
 775   1      } // end findMenu()
 776          
 777          // -------------------------------------------------------------- //
 778          
 779          void tempMenu( void ) {
 780   1      
 781   1              struct keypad_data keypad;
 782   1              bool exit = false;
 783   1              int i = 0;
 784   1      
 785   1              while( exit == false ) {
 786   2      
 787   2                      char MenuStr1[] = "Current Temperature`";
 788   2                      char MenuStr2[] = "+00.0 F`";
 789   2                      //char MenuStr3[] = " `";
 790   2                      char MenuStr4[] = "# : Return to I/O   `";
 791   2              
 792   2                      lcdClear();
 793   2                      lcdString( &MenuStr1 );
 794   2      
 795   2                      lcdLine(2);
 796   2                      sprintf( MenuStr2, "%+5.1f F`", getTemp() );
 797   2                      lcdString( &MenuStr2 );
 798   2      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 14  

 799   2                      //lcdLine(3);
 800   2                      //lcdString( &MenuStr3 );
 801   2                      lcdLine(4);
 802   2                      lcdString( &MenuStr4 );
 803   2              
 804   2                      while(1) {      
 805   3      
 806   3                              // slow LCD temp refresh rate down
 807   3                              if ( i == 1000 ) {
 808   4                                      lcdLine(2);
 809   4                                      sprintf( MenuStr2, "%+5.1f F`", getTemp() );
 810   4                                      lcdString( &MenuStr2 );
 811   4                                      i = 0;
 812   4                              }
 813   3                              else {
 814   4                                      i++;
 815   4                              }
 816   3      
 817   3                              keypad = getKeysPressed();
 818   3                      
 819   3                              if( keypad.kpound == true ) {
 820   4                                      exit = true;
 821   4                                      waitForKeyRelease();
 822   4                                      break;
 823   4                              }
 824   3      
 825   3                      } // end option while
 826   2      
 827   2              } // end main while
 828   1      
 829   1      } // end tempMenu()
 830          
 831          // -------------------------------------------------------------- //
 832          
 833          void sevenSegMenu( void ) {
 834   1      
 835   1              struct keypad_data keypad;
 836   1              bool exit = false;
 837   1              int i = 0;
 838   1      
 839   1              while( exit == false ) {
 840   2      
 841   2                      char MenuStr1[] = "Seven Segment`";
 842   2                      char MenuStr2[] = "Display Demo`";
 843   2                      //char MenuStr3[] = " `";
 844   2                      char MenuStr4[] = "# : Return to I/O`";
 845   2              
 846   2                      lcdClear();
 847   2                      lcdString( &MenuStr1 );
 848   2      
 849   2                      lcdLine(2);
 850   2                      lcdString( &MenuStr2 );
 851   2      
 852   2                      //lcdLine(3);
 853   2                      //lcdString( &MenuStr3 );
 854   2                      lcdLine(4);
 855   2                      lcdString( &MenuStr4 );
 856   2              
 857   2                      while(1) {      
 858   3      
 859   3                              keypad = getKeysPressed();
 860   3                      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 15  

 861   3                              if( keypad.kpound == true ) {
 862   4                                      exit = true;
 863   4                                      outputSevenSeg('o'); // Turn display off when exiting
 864   4                                      waitForKeyRelease();
 865   4                                      break;
 866   4                              }
 867   3      
 868   3                              switch (i) {
 869   4                                      
 870   4                                      case 0: sevenSegPort = 0xFE; break;
 871   4                                      case 1: sevenSegPort = 0xFD; break;
 872   4                                      case 2: sevenSegPort = 0xFB; break;
 873   4                                      case 3: sevenSegPort = 0xF7; break;
 874   4                                      case 4: sevenSegPort = 0xEF; break;
 875   4                                      case 5: sevenSegPort = 0xDF; break;
 876   4                                      case 6: sevenSegPort = 0xBF; break;
 877   4                                      case 7: sevenSegPort = 0x7F; break;
 878   4                                      default: sevenSegPort = 0xFF; break;
 879   4      
 880   4                              } // end switch
 881   3      
 882   3                              if( i >= 7 ) {
 883   4                                      i = 0;
 884   4                              } else {
 885   4                                      i++;
 886   4                              }
 887   3      
 888   3                              latchSevenSeg();
 889   3                              msDelay(50);
 890   3      
 891   3                      } // end option while
 892   2      
 893   2              } // end main while
 894   1      
 895   1      } // end sevenSegMenu()
 896          
 897          // -------------------------------------------------------------- //
 898          
 899          void timeMenu( void ) {
 900   1      
 901   1              struct keypad_data keypad;
 902   1              bool exit = false;
 903   1              int i = 0;
 904   1              struct time_data time;
 905   1      
 906   1              while( exit == false ) {
 907   2      
 908   2                      char MenuStr1[] = "Real Time Clock`";
 909   2                      //char MenuStr2[] = "<Time>`";
 910   2                      //char MenuStr3[] = " `";
 911   2                      char MenuStr4[] = "# : Return to I/O   `";
 912   2              
 913   2                      lcdClear();
 914   2                      lcdString( &MenuStr1 );
 915   2      
 916   2                      lcdLine(2);
 917   2                      time = rtcGetTime();
 918   2                      rtcPrintTime( &time );
 919   2      
 920   2                      //lcdLine(3);
 921   2                      //lcdString( &MenuStr3 );
 922   2                      lcdLine(4);
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 16  

 923   2                      lcdString( &MenuStr4 );
 924   2              
 925   2                      while(1) {      
 926   3      
 927   3                              // slow LCD time refresh rate down
 928   3                              if ( i == 1000 ) {
 929   4                                      lcdLine(2);
 930   4                                      time = rtcGetTime();
 931   4                                      rtcPrintTime( &time );
 932   4                                      i = 0;
 933   4                              }
 934   3                              else {
 935   4                                      i++;
 936   4                              }
 937   3      
 938   3                              keypad = getKeysPressed();
 939   3                      
 940   3                              if( keypad.kpound == true ) {
 941   4                                      exit = true;
 942   4                                      waitForKeyRelease();
 943   4                                      break;
 944   4                              }
 945   3      
 946   3                      } // end option while
 947   2      
 948   2              } // end main while
 949   1      
 950   1      } // end timeMenu()
 951          
 952          // -------------------------------------------------------------- //
 953          
 954          void stopwatchMenu( void ) {
 955   1      
 956   1              struct keypad_data keypad;
 957   1              struct time_data original_start_time;
 958   1              struct time_data start_time;
 959   1              struct time_data current_time;
 960   1              struct time_data timer;
 961   1              bool exit;
 962   1              bool running;
 963   1              int i;
 964   1      
 965   1              char MenuStr1[] = "Stopwatch`";
 966   1              char MenuStr2[] = "No timer started    `";
 967   1              char MenuStr3[] = "1: Start     2: Stop`";
 968   1              char MenuStr4[] = "3: Clear     #: Exit`";
 969   1      
 970   1              exit = false;
 971   1              running = false;
 972   1              i = 0;
 973   1      
 974   1              // Initial display
 975   1              lcdClear();
 976   1              lcdString( &MenuStr1 );
 977   1              lcdLine(2);
 978   1              lcdString( &MenuStr2 );
 979   1              lcdLine(3);
 980   1              lcdString( &MenuStr3 );
 981   1              lcdLine(4);
 982   1              lcdString( &MenuStr4 ); 
 983   1              
 984   1              while( exit == false ) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 17  

 985   2              
 986   2                      while(1) {      
 987   3      
 988   3                              if ( running == true) {
 989   4                                      // slow LCD time refresh rate down
 990   4                                      if ( i == 1000 ) {
 991   5                                              
 992   5                                              current_time = rtcGetTime();
 993   5                                              start_time = original_start_time;
 994   5                      
 995   5                                              //timer = current_time - start_time;
 996   5                                              // seconds
 997   5                                              if( current_time.seconds >= start_time.seconds ) {
 998   6                                                      timer.seconds = current_time.seconds - start_time.seconds;
 999   6                                              }
1000   5                                              else {
1001   6                                                      timer.seconds = current_time.seconds + 60 - start_time.seconds;
1002   6                                                      current_time.minutes--;
1003   6                                              }
1004   5                                              // minutes
1005   5                                              if( current_time.minutes >= start_time.minutes ) {
1006   6                                                      timer.minutes = current_time.minutes - start_time.minutes;
1007   6                                              }
1008   5                                              else {
1009   6                                                      timer.minutes = current_time.minutes + 60 - start_time.minutes;
1010   6                                                      current_time.hours--;
1011   6                                              }
1012   5                                              // hours
1013   5                                              if( current_time.hours >= start_time.hours ) {
1014   6                                                      timer.hours = current_time.hours - start_time.hours;
1015   6                                              }
1016   5                                              else {
1017   6                                                      timer.hours = current_time.hours + 24 - start_time.hours;
1018   6                                                      current_time.days--;
1019   6                                              }
1020   5                                              // days
1021   5                                              if( current_time.days >= start_time.days ) {
1022   6                                                      timer.days = current_time.days - start_time.days;
1023   6                                              }
1024   5                                              else {
1025   6                                                      timer.days = current_time.days + 30 - start_time.days;
1026   6                                                      current_time.months--;
1027   6                                              }
1028   5                                              // months
1029   5                                              if( current_time.months >= start_time.months ) {
1030   6                                                      timer.months = current_time.months - start_time.months;
1031   6                                              }
1032   5                                              else {
1033   6                                                      timer.months = current_time.months + 12 - start_time.months;
1034   6                                                      current_time.years--;
1035   6                                              }
1036   5                                              // years
1037   5                                              timer.years = start_time.years - current_time.years;
1038   5                                              //
1039   5                                              timer.week = current_time.week;
1040   5                      
1041   5                                              lcdLine(2);
1042   5                                              rtcPrintTime( &timer );
1043   5                                              i = 0;
1044   5                                      }
1045   4                                      else {
1046   5                                              i++;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 18  

1047   5                                      }
1048   4                              } // end running
1049   3              
1050   3                              keypad = getKeysPressed();
1051   3                      
1052   3                              if( keypad.kpound == true ) {
1053   4                                      exit = true;
1054   4                                      waitForKeyRelease();
1055   4                                      break;
1056   4                              }
1057   3                              if( keypad.k1 == true ) {
1058   4                                      // Start timer
1059   4                                      running = true;
1060   4                                      original_start_time = rtcGetTime();
1061   4                                      waitForKeyRelease();
1062   4                                      break;
1063   4                              }
1064   3                              if( keypad.k2 == true ) {
1065   4                                      // Stop timer
1066   4                                      running = false;
1067   4                                      waitForKeyRelease();
1068   4                                      break;
1069   4                              }
1070   3                              if( keypad.k3 == true ) {
1071   4                                      // Clear timer
1072   4                                      running = false;
1073   4                                      lcdLine(2);
1074   4                                      lcdString( &MenuStr2 );
1075   4                                      waitForKeyRelease();
1076   4                                      break;
1077   4                              }
1078   3              
1079   3                      } // end option while
1080   2      
1081   2              } // end main while
1082   1      
1083   1      } // end stopwatchMenu()
1084          
1085          // -------------------------------------------------------------- //
1086          
1087          word input4Hex( void ) {
1088   1      
1089   1              word segment;
1090   1              word input;
1091   1              int i;
1092   1              
1093   1              segment = 0x0000;
1094   1      
1095   1              for( i = 0; i < 4; i++ ) {
1096   2                      segment = segment << 4;
1097   2                      input = inputHex();
1098   2                      segment = segment + input;
1099   2              }
1100   1         
1101   1              return segment;
1102   1      
1103   1      } // end input4Hex()
1104          
1105          // -------------------------------------------------------------- //
1106          
1107          byte input2Hex( void ) {
1108   1      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 19  

1109   1              byte value;
1110   1              word input;
1111   1              int i;
1112   1              
1113   1              value = 0x00;
1114   1      
1115   1              for( i = 0; i < 2; i++ ) {
1116   2                      value = value << 4;
1117   2                      input = inputHex();
1118   2                      value = value + input;
1119   2              }
1120   1         
1121   1              return value;
1122   1      
1123   1      } // end input2Hex()
1124          
1125          // -------------------------------------------------------------- //
1126          
1127          word inputHex( void ) {
1128   1      
1129   1              struct keypad_data keypad;
1130   1              word value;
1131   1              byte ascii;
1132   1              
1133   1              
1134   1              value = 0xFFFF;
1135   1              ascii = 0x7E;
1136   1              
1137   1              while( value == 0xFFFF ) {
1138   2                
1139   2                      keypad = getKeysPressed();
1140   2      
1141   2                      if( keypad.k0 == true ) {
1142   3                              value = 0x0000;
1143   3                              ascii = 0x30;
1144   3                      }
1145   2                      if( keypad.k1 == true ) {
1146   3                              value = 0x0001;
1147   3                              ascii = 0x31;
1148   3                      }
1149   2                      if( keypad.k2 == true ) {
1150   3                              value = 0x0002;
1151   3                              ascii = 0x32;
1152   3                      }
1153   2                      if( keypad.k3 == true ) {
1154   3                              value = 0x0003;
1155   3                              ascii = 0x33;
1156   3                      }
1157   2                      if( keypad.k4 == true ) {
1158   3                              value = 0x0004;
1159   3                              ascii = 0x34;
1160   3                      }
1161   2                      if( keypad.k5 == true ) {
1162   3                              value = 0x0005;
1163   3                              ascii = 0x35;
1164   3                      }
1165   2                      if( keypad.k6 == true ) {
1166   3                              value = 0x0006;
1167   3                              ascii = 0x36;
1168   3                      }
1169   2                      if( keypad.k7 == true ) {
1170   3                              value = 0x0007;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 20  

1171   3                              ascii = 0x37;
1172   3                      }
1173   2                      if( keypad.k8 == true ) {
1174   3                              value = 0x0008;
1175   3                              ascii = 0x38;
1176   3                      }
1177   2                      if( keypad.k9 == true ) {
1178   3                              value = 0x0009;
1179   3                              ascii = 0x39;
1180   3                      }
1181   2                      if( keypad.kA == true ) {
1182   3                              value = 0x000A;
1183   3                              ascii = 0x41;
1184   3                      }
1185   2                      if( keypad.kB == true ) {
1186   3                              value = 0x000B;
1187   3                              ascii = 0x42;
1188   3                      }
1189   2                      if( keypad.kC == true ) {
1190   3                              value = 0x000C;
1191   3                              ascii = 0x43;
1192   3                      }
1193   2                      if( keypad.kD == true ) {
1194   3                              value = 0x000D;
1195   3                              ascii = 0x44;
1196   3                      }
1197   2                      if( keypad.kstar == true ) {
1198   3                              value = 0x000E;
1199   3                              ascii = 0x45;
1200   3                      }
1201   2                      if( keypad.kpound == true ) {
1202   3                              value = 0x000F;
1203   3                              ascii = 0x46;
1204   3                      }
1205   2      
1206   2              } // end while
1207   1      
1208   1              lcdChar( ascii );
1209   1      
1210   1              waitForKeyRelease();
1211   1              return value;   
1212   1      
1213   1      } // end readHex()
1214          
1215          // -------------------------------------------------------------- //
1216          
1217          void waitForKeyRelease( void ) {
1218   1      
1219   1              struct keypad_data keypad;
1220   1              bool exit = false;
1221   1              
1222   1              while( exit == false ) {
1223   2      
1224   2                      exit = true;
1225   2                      keypad = getKeysPressed();
1226   2      
1227   2                      if( keypad.k0 == true ) {
1228   3                              exit = false;
1229   3                      }
1230   2                      if( keypad.k1 == true ) {
1231   3                              exit = false;
1232   3                      }
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 21  

1233   2                      if( keypad.k2 == true ) {
1234   3                              exit = false;
1235   3                      }
1236   2                      if( keypad.k3 == true ) {
1237   3                              exit = false;
1238   3                      }
1239   2                      if( keypad.k4 == true ) {
1240   3                              exit = false;
1241   3                      }
1242   2                      if( keypad.k5 == true ) {
1243   3                              exit = false;
1244   3                      }
1245   2                      if( keypad.k6 == true ) {
1246   3                              exit = false;
1247   3                      }
1248   2                      if( keypad.k7 == true ) {
1249   3                              exit = false;
1250   3                      }
1251   2                      if( keypad.k8 == true ) {
1252   3                              exit = false;
1253   3                      }
1254   2                      if( keypad.k9 == true ) {
1255   3                              exit = false;
1256   3                      }
1257   2                      if( keypad.kA == true ) {
1258   3                              exit = false;
1259   3                      }
1260   2                      if( keypad.kB == true ) {
1261   3                              exit = false;
1262   3                      }
1263   2                      if( keypad.kC == true ) {
1264   3                              exit = false;
1265   3                      }
1266   2                      if( keypad.kD == true ) {
1267   3                              exit = false;
1268   3                      }
1269   2                      if( keypad.kstar == true ) {
1270   3                              exit = false;
1271   3                      }
1272   2                      if( keypad.kpound == true ) {
1273   3                              exit = false;
1274   3                      }
1275   2      
1276   2              } // end while
1277   1              
1278   1              msDelay(100);     
1279   1      
1280   1      } // end waitForKeyRelease()
1281          
1282          // -------------------------------------------------------------- //
1283          
1284          void latchSevenSeg( void ) {
1285   1              
1286   1      //      cs_sevenSeg = 1;
1287   1      //      cs_sevenSeg = 0;
1288   1              
1289   1              missionControl1( ctrl_ss_latch );
1290   1              missionControl1( ctrl_off );
1291   1              
1292   1      } // end latchSevenSeg()
1293          
1294          // -------------------------------------------------------------- //
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 22  

1295          
1296          void latchKeypad( void ) {
1297   1              
1298   1      //      cs_keypad = 1;
1299   1      //      cs_keypad = 0;
1300   1              
1301   1              missionControl1( ctrl_kp_oelatch );
1302   1              missionControl1( ctrl_kp_oe );
1303   1              
1304   1      } // end latchKeypad()
1305          
1306          
1307          // -------------------------------------------------------------- //
1308          
1309          void outputSevenSeg( char character ) {
1310   1              
1311   1              switch( character ) {
1312   2                      case '0': sevenSegPort = ~0x3F; break;
1313   2                      case '1': sevenSegPort = ~0x06; break;
1314   2                      case '2': sevenSegPort = ~0x5B; break;
1315   2                      case '3': sevenSegPort = ~0x4F; break;
1316   2                      case '4': sevenSegPort = ~0x66; break;
1317   2                      case '5': sevenSegPort = ~0x6D; break;
1318   2                      case '6': sevenSegPort = ~0x7D; break;
1319   2                      case '7': sevenSegPort = ~0x07; break;
1320   2                      case '8': sevenSegPort = ~0x7F; break;
1321   2                      case '9': sevenSegPort = ~0x67; break;
1322   2                      case 'A': sevenSegPort = ~0x77; break;
1323   2                      case 'b': sevenSegPort = ~0x7C; break;
1324   2                      case 'C': sevenSegPort = ~0x39; break;
1325   2                      case 'd': sevenSegPort = ~0x5E; break;
1326   2                      case 'E': sevenSegPort = ~0x79; break;
1327   2                      case 'F': sevenSegPort = ~0x71; break;
1328   2                      case '-': sevenSegPort = 0xBF;  break;
1329   2                      case '.': sevenSegPort = 0x7F;  break;
1330   2                      case 'o': sevenSegPort = 0xFF;  break;  // off
1331   2                      default:  sevenSegPort = 0xAA;                                  // invalid
1332   2              }
1333   1              
1334   1              latchSevenSeg();
1335   1              
1336   1      } // end outputSevenSeg()
1337          
1338          // -------------------------------------------------------------- //
1339          
1340          struct keypad_data getKeysPressed( void ) {
1341   1              
1342   1              struct keypad_data keypad;
1343   1              
1344   1              // enable keypad latch output
1345   1              //oe_keypad = 0;
1346   1              missionControl1( ctrl_kp_oe );
1347   1              
1348   1              // Set keypad columns as outputs & rows as inputs
1349   1              kCol1 = 0;
1350   1              kCol2 = 0;
1351   1              kCol3 = 0;
1352   1              kCol4 = 0;
1353   1              kRow1 = 1;
1354   1              kRow2 = 1;
1355   1              kRow3 = 1;
1356   1              kRow4 = 1;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 23  

1357   1              
1358   1              // scan by columns
1359   1      
1360   1              // column 1
1361   1              kCol1 = 0;
1362   1              kCol2 = 1;
1363   1              kCol3 = 1;
1364   1              kCol4 = 1;
1365   1              latchKeypad();
1366   1              
1367   1              if (kRow1 == 0) {
1368   2                      keypad.k1 = 1;
1369   2              }
1370   1              else {
1371   2                      keypad.k1 = 0;
1372   2              }
1373   1              if (kRow2 == 0) {
1374   2                      keypad.k4 = 1;
1375   2              }
1376   1              else {
1377   2                      keypad.k4 = 0;
1378   2              }
1379   1              if (kRow3 == 0) {
1380   2                      keypad.k7 = 1;
1381   2              }
1382   1              else {
1383   2                      keypad.k7 = 0;
1384   2              }
1385   1              if (kRow4 == 0) {
1386   2                      keypad.kstar = 1;
1387   2              }
1388   1              else {
1389   2                      keypad.kstar = 0;
1390   2              }
1391   1              kCol1 = 1;
1392   1              
1393   1              // column 2
1394   1              kCol2 = 0;
1395   1              latchKeypad();
1396   1              
1397   1              if (kRow1 == 0) {
1398   2                      keypad.k2 = 1;
1399   2              }
1400   1              else {
1401   2                      keypad.k2 = 0;
1402   2              }
1403   1              if (kRow2 == 0) {
1404   2                      keypad.k5 = 1;
1405   2              }
1406   1              else {
1407   2                      keypad.k5 = 0;
1408   2              }
1409   1              if (kRow3 == 0) {
1410   2                      keypad.k8 = 1;
1411   2              }
1412   1              else {
1413   2                      keypad.k8 = 0;
1414   2              }
1415   1              if (kRow4 == 0) {
1416   2                      keypad.k0 = 1;
1417   2              }
1418   1              else {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 24  

1419   2                      keypad.k0 = 0;
1420   2              }
1421   1              kCol2 = 1;
1422   1              
1423   1              // column 3
1424   1              kCol3 = 0;
1425   1              latchKeypad();
1426   1              
1427   1              if (kRow1 == 0) {
1428   2                      keypad.k3 = 1;
1429   2              }
1430   1              else {
1431   2                      keypad.k3 = 0;
1432   2              }
1433   1              if (kRow2 == 0) {
1434   2                      keypad.k6 = 1;
1435   2              }
1436   1              else {
1437   2                      keypad.k6 = 0;
1438   2              }
1439   1              if (kRow3 == 0) {
1440   2                      keypad.k9 = 1;
1441   2              }
1442   1              else {
1443   2                      keypad.k9 = 0;
1444   2              }
1445   1              if (kRow4 == 0) {
1446   2                      keypad.kpound = 1;
1447   2              }
1448   1              else {
1449   2                      keypad.kpound = 0;
1450   2              }
1451   1              kCol3 = 1;
1452   1              
1453   1              // column 4
1454   1              kCol4 = 0;
1455   1              latchKeypad();
1456   1              
1457   1              if (kRow1 == 0) {
1458   2                      keypad.kA = 1;
1459   2              }
1460   1              else {
1461   2                      keypad.kA = 0;
1462   2              }
1463   1              if (kRow2 == 0) {
1464   2                      keypad.kB = 1;
1465   2              }
1466   1              else {
1467   2                      keypad.kB = 0;
1468   2              }
1469   1              if (kRow3 == 0) {
1470   2                      keypad.kC = 1;
1471   2              }
1472   1              else {
1473   2                      keypad.kC = 0;
1474   2              }
1475   1              if (kRow4 == 0) {
1476   2                      keypad.kD = 1;
1477   2              }
1478   1              else {
1479   2                      keypad.kD = 0;
1480   2              }
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 25  

1481   1              kCol4 = 1;
1482   1              latchKeypad();
1483   1              
1484   1              // disable keypad latch output
1485   1              //oe_keypad = 1;
1486   1              missionControl1( ctrl_off );
1487   1              
1488   1              return keypad; 
1489   1              
1490   1      } // end getKeysPressed()
1491          
1492          // -------------------------------------------------------------- //
1493          
1494          void displayKeyPressed( struct keypad_data keypad ) {
1495   1              
1496   1              if ( keypad.k1 == 1 ) {
1497   2                      outputSevenSeg('1');
1498   2              }
1499   1              else if ( keypad.k2 == 1 ) {
1500   2                      outputSevenSeg('2');
1501   2              }
1502   1              else if ( keypad.k3 == 1 ) {
1503   2                      outputSevenSeg('3');
1504   2              }
1505   1              else if ( keypad.k4 == 1 ) {
1506   2                      outputSevenSeg('4');
1507   2              }
1508   1              else if ( keypad.k5 == 1 ) {
1509   2                      outputSevenSeg('5');
1510   2              }
1511   1              else if ( keypad.k6 == 1 ) {
1512   2                      outputSevenSeg('6');
1513   2              }
1514   1              else if ( keypad.k7 == 1 ) {
1515   2                      outputSevenSeg('7');
1516   2              }
1517   1              else if ( keypad.k8 == 1 ) {
1518   2                      outputSevenSeg('8');
1519   2              }
1520   1              else if ( keypad.k9 == 1 ) {
1521   2                      outputSevenSeg('9');
1522   2              }
1523   1              else if ( keypad.kA == 1 ) {
1524   2                      outputSevenSeg('A');
1525   2              }
1526   1              else if ( keypad.k0 == 1 ) {
1527   2                      outputSevenSeg('0');
1528   2              }
1529   1              else if ( keypad.kB == 1 ) {
1530   2                      outputSevenSeg('b');
1531   2              }
1532   1              else if ( keypad.kC == 1 ) {
1533   2                      outputSevenSeg('C');
1534   2              }
1535   1              else if ( keypad.kD == 1 ) {
1536   2                      outputSevenSeg('d');
1537   2              }
1538   1              else if ( keypad.kstar == 1 ) {
1539   2                      outputSevenSeg('.');
1540   2              }
1541   1              else if ( keypad.kpound == 1 ) {
1542   2                      outputSevenSeg('-');
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 26  

1543   2              }
1544   1              else {
1545   2                      outputSevenSeg('o');
1546   2              }
1547   1              
1548   1      } // end displayKeyPressed()
1549                  
1550          // -------------------------------------------------------------- //
1551          
1552          void lcdCmd( byte cmd ) {
1553   1              
1554   1              //rs_lcd = 0;                   // reg select low for command
1555   1              // --- RW tied low for write --- //
1556   1              //e_lcd = 1;                    // E high for pulse
1557   1              
1558   1              missionControl1( ctrl_lcd_cmd_start );
1559   1              
1560   1              lcdPort = cmd;
1561   1              //latchLCD();
1562   1              
1563   1              msDelay(1);                     // Need Tpw > 140 ns
1564   1              //e_lcd = 0;                    // E low to end pulse
1565   1              
1566   1              missionControl1( ctrl_lcd_cmd_finish );
1567   1              
1568   1      } // end lcdCmd()
1569          
1570          // -------------------------------------------------------------- //
1571          
1572          void lcdData( byte dat ) {
1573   1              
1574   1              //rs_lcd = 1;                   // reg select high for data
1575   1              // --- RW tied low for write --- //
1576   1              //e_lcd = 1;                    // E high for pulse
1577   1              
1578   1              missionControl1( ctrl_lcd_data_start );
1579   1              
1580   1              lcdPort = dat;
1581   1              //latchLCD();
1582   1              
1583   1              msDelay(1);                     // Need Tpw > 140 ns
1584   1              //e_lcd = 0;                    // E low to end pulse
1585   1              
1586   1              missionControl1( ctrl_lcd_data_finish );
1587   1              
1588   1      } // end lcdData()
1589          
1590          // -------------------------------------------------------------- //
1591          
1592          void lcdInit( void ) {  
1593   1              
1594   1              msDelay(50);
1595   1              lcdCmd(0x38);                   // Function set
1596   1              msDelay(5);
1597   1              lcdCmd(0x38);                   // Function set
1598   1              msDelay(1);
1599   1              lcdCmd(0x0F);                   // Display ON/OFF control
1600   1              msDelay(1);
1601   1              lcdCmd(0x01);                   // Clear display
1602   1              msDelay(2);
1603   1              
1604   1      } // end lcdInit()
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 27  

1605          
1606          // -------------------------------------------------------------- //
1607          
1608          void lcdClear( void ) {
1609   1              
1610   1              lcdCmd(0x01);                   // Clear display
1611   1              msDelay(2);
1612   1              
1613   1      } // end lcdClear()
1614          
1615          // -------------------------------------------------------------- //
1616          
1617          void lcdChar( byte character ) {
1618   1              
1619   1              lcdData(character);             // send character
1620   1              
1621   1      } // end lcdChar()
1622          
1623          // -------------------------------------------------------------- //
1624          
1625          void lcdString( volatile char *string ) {
1626   1              
1627   1              int i = 0;
1628   1              while( string[i] != '`') {
1629   2                      lcdChar( string[i] );
1630   2                      i++;
1631   2              }
1632   1              
1633   1      } // end lcdString()
1634          
1635          // -------------------------------------------------------------- //
1636          
1637          void lcdLine( int line ) {
1638   1              
1639   1              switch (line) {
1640   2                      case 1: {
1641   3                              lcdCmd(0x80);
1642   3                              break;
1643   3                      }
1644   2                      case 2: {
1645   3                              lcdCmd(0xC0);
1646   3                              break;
1647   3                      }
1648   2                      case 3: {
1649   3                              lcdCmd(0x94);
1650   3                              break;
1651   3                      }
1652   2                      case 4: {
1653   3                              lcdCmd(0xD4);
1654   3                              break;
1655   3                      }
1656   2                      default:
1657   2                              lcdCmd(0x80);
1658   2                      
1659   2              } // end switch
1660   1              
1661   1      } // end lcdLine()
1662          
1663          // -------------------------------------------------------------- //
1664          
1665          void lcdHexWord( word hex ) {
1666   1      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 28  

1667   1              char hexStr[] = "--------`";
1668   1      
1669   1              sprintf( hexStr, "%04X`", (int)hex );
1670   1              lcdString( &hexStr );
1671   1      
1672   1      } // end lcdHexWord()
1673          
1674          // -------------------------------------------------------------- //
1675          
1676          void lcdHexByte( byte hex ) {
1677   1      
1678   1              char hexStr[] = "-----`";
1679   1      
1680   1              sprintf( hexStr, "%02X`", (int)hex );
1681   1              lcdString( &hexStr );
1682   1      
1683   1      } // end lcdHexWord()
1684          
1685          // -------------------------------------------------------------- //
1686          
1687          void lcdAsciiByte( byte hex ) {
1688   1      
1689   1      //      char hexStr[] = "-----`";
1690   1      //
1691   1      //      sprintf( hexStr, "%1c`", (int)hex );
1692   1      //      lcdString( &hexStr );
1693   1      
1694   1              lcdChar( hex );
1695   1      
1696   1      } // end lcdHexWord()
1697          
1698          // -------------------------------------------------------------- //
1699          
1700          float getTemp( void ) {
1701   1              
1702   1              //------------ IDEA ------------------------------------------//
1703   1              // change to pass in C or F and returns corresponding value.  //
1704   1              
1705   1              int i = 0;
1706   1              byte sample = 0;
1707   1              float voltage = 0;
1708   1              float degC = 0;
1709   1              float degF = 0;
1710   1              int degCint = 0;
1711   1      //      char tempCStr[] = "+00.0 C`";
1712   1      //      char tempFStr[] = "+00.0 F`";
1713   1      //      char voltStr[] = "+0.0 V`";
1714   1      //      char sampStr[] = "55555555`";
1715   1              
1716   1                      missionControl2( ctrl_adc_start );
1717   1                      missionControl2( ctrl_adc_finish );
1718   1                      sample = adcPort;
1719   1                      missionControl2( ctrl_off );
1720   1                      
1721   1                      // voltage reading in 0.3V higher than measured on board
1722   1                      voltage = sample * 5 / 256;
1723   1                      //voltage = voltage - 0.25;
1724   1                      degC = (voltage - 0.5) * 100;
1725   1                      degF = degC * (9.0/5.0) + 32.0;
1726   1                      
1727   1                      return degF;
1728   1                      
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 29  

1729   1      //              sprintf( sampStr, "%c`", sample );
1730   1      //              sprintf( voltStr, "%+4.1f V`", voltage );
1731   1      //              sprintf( tempCStr, "%+5.1f C`", degC );
1732   1      //              sprintf( tempFStr, "%+5.1f F`", degF );
1733   1                      
1734   1      //              lcdLine(1);
1735   1      //              lcdString( &sampStr );
1736   1      //              lcdLine(2);
1737   1      //              lcdString( &voltStr );
1738   1      //              lcdLine(3);
1739   1      //              lcdString( &tempCStr );
1740   1      //              lcdLine(4);
1741   1      //              lcdString( &tempFStr );
1742   1              
1743   1      } // end getDegF()
1744          
1745          // -------------------------------------------------------------- //
1746          
1747          void rtcInit( void ) {
1748   1              
1749   1              struct time_data time;
1750   1      
1751   1              time.week = 0;
1752   1              time.years = 17;
1753   1              time.months = 3;
1754   1              time.days = 26;
1755   1              time.hours = 12;
1756   1              time.minutes = 21;
1757   1              time.seconds = 0;
1758   1                      
1759   1              // (A)  Start the counter
1760   1              //                      Inititalize the control registers
1761   1              rtcWrite( 0xF4 );               // Set the CF register to 0100b = 4h
1762   1              rtcWrite( 0xD4 );               // Set the CD register to 0100b = 4h
1763   1              
1764   1              // (B)  Check the status of the BUSY bit
1765   1              rtcBusy();      
1766   1              
1767   1              // (C)  STOP and RESET the counter
1768   1              rtcWrite( 0xF7 );               // Set the CF register to 0111b = 7h
1769   1              
1770   1              // Set the current time in the registers
1771   1              //              (initizlize the S1 to W registers)
1772   1              rtcSetTime( time ); 
1773   1              
1774   1              // (A)  Start the counter and release the HOLD status
1775   1              rtcWrite( 0xF4 );               // Set the CF register to 0100b = 4h
1776   1              rtcWrite( 0xD5 );               // Set the CD register to 0101b = 5h
1777   1              
1778   1      } // end rtcInit()
1779          
1780          // -------------------------------------------------------------- //
1781          
1782          void rtcBusy( void ) {
1783   1              
1784   1              byte duhdata;
1785   1              
1786   1              rtcWrite( 0xD5 );                                               // Hold bit <- 1
1787   1              duhdata = rtcRead( 0x0D );      // Read from D to get BUSY// Read the BUSY bit
1788   1      
1789   1              // If BUSY bit = 0, cont., else HOLD bit <- 0
1790   1              while( duhdata & 0x02 == 2 ) {
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 30  

1791   2                      rtcWrite( 0xD4 );                                               // HOLD bit <- 0
1792   2                      rtcWrite( 0xD5 );                                               // HOLD bit <- 1
1793   2                      duhdata = rtcRead( 0x0D );      // Read from D to get BUSY// Read the BUSY bit
1794   2              }       
1795   1              
1796   1      } // end rtcBusy()
1797          
1798          // -------------------------------------------------------------- //
1799          
1800          void rtcWrite( byte duhdata ) {
1801   1              
1802   1              missionControl2( ctrl_rtc_cs1 );        // set CS1 high
1803   1              rtcPort = duhdata;                                      // send duhdata
1804   1              missionControl2( ctrl_rtc_cs0 );        // set CS0 low
1805   1              missionControl2( ctrl_rtc_wr );         // set WR low
1806   1              missionControl2( ctrl_rtc_cs0 );        // set WR high
1807   1              missionControl2( ctrl_rtc_cs1 );        // set CS0 high
1808   1              missionControl2( ctrl_off );            // set CS1 low
1809   1              
1810   1      } // end rtcWrite()
1811          
1812          // -------------------------------------------------------------- //
1813          
1814          byte rtcRead( byte duhaddress ) {
1815   1              
1816   1              byte duhdata = 0x00;
1817   1              
1818   1              duhaddress = duhaddress << 4;
1819   1              duhaddress = duhaddress | 0x0F;
1820   1              
1821   1              missionControl2( ctrl_rtc_cs1 );        // set CS1 high
1822   1              rtcPort = duhaddress;                           // send duhaddress
1823   1              missionControl2( ctrl_rtc_cs0 );        // set CS0 low
1824   1              missionControl2( ctrl_rtc_rd );         // set RD low
1825   1              duhdata = rtcPort;                                      // read duhdata
1826   1              duhdata &= 0x0F;                                        // mask upper nibble of value read in
1827   1              missionControl2( ctrl_rtc_cs0 );        // set RD high
1828   1              missionControl2( ctrl_rtc_cs1 );        // set CS0 high
1829   1              missionControl2( ctrl_off );            // set CS1 low
1830   1              
1831   1              return duhdata;
1832   1              
1833   1      } // end rtcRead()
1834          
1835          // -------------------------------------------------------------- //
1836          
1837          void rtcRegWrite( byte duhstuff ) {
1838   1              
1839   1              rtcBusy();
1840   1              rtcWrite( duhstuff );
1841   1              // HOLD bit <- 0 by rtcWrite when CS1 is cleared
1842   1              
1843   1      } // end rtcRegWrite()
1844          
1845          // -------------------------------------------------------------- //
1846          
1847          byte rtcRegRead( byte duhstuff ) {
1848   1              
1849   1              byte duhdata;
1850   1      
1851   1              rtcBusy();
1852   1              duhdata = rtcRead( duhstuff );
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 31  

1853   1              // HOLD bit <- 0 by rtcWrite when CS1 is cleared
1854   1              return duhdata;
1855   1              
1856   1      } // end rtcRegWrite()
1857          
1858          // -------------------------------------------------------------- //
1859          
1860          void rtcSetTime( struct time_data time ) {
1861   1              
1862   1              byte s1, s10, mi1, mi10, h1, h10, d1, d10, mo1, mo10, y1, y10;
1863   1              
1864   1              // 1-second
1865   1              s1 = time.seconds % 10;
1866   1              rtcRegWrite( 0x00 | s1 );
1867   1              
1868   1              // 10-second
1869   1              s10 = time.seconds / 10;
1870   1              rtcRegWrite( 0x10 | s10 );
1871   1              
1872   1              // 1-minute
1873   1              mi1 = time.minutes % 10;
1874   1              rtcRegWrite( 0x20 | mi1 );
1875   1              
1876   1              // 10-minute
1877   1              mi10 = time.minutes / 10;
1878   1              rtcRegWrite( 0x30 | mi10 );
1879   1              
1880   1              // 1-hour
1881   1              h1 = time.hours % 10;
1882   1              rtcRegWrite( 0x40 | h1 );
1883   1              
1884   1              // 10-hour
1885   1              h10 = time.hours / 10;
1886   1              rtcRegWrite( 0x50 | h10 );
1887   1              
1888   1              // 1-day
1889   1              d1 = time.days % 10;
1890   1              rtcRegWrite( 0x60 | d1 );
1891   1              
1892   1              // 10-day
1893   1              d10 = time.days / 10;
1894   1              rtcRegWrite( 0x70 | d10 );
1895   1              
1896   1              // 1-month
1897   1              mo1 = time.months % 10;
1898   1              rtcRegWrite( 0x80 | mo1 );
1899   1              
1900   1              // 10-month
1901   1              mo10 = time.months / 10;
1902   1              rtcRegWrite( 0x90 | mo10 );
1903   1              
1904   1              // 1-year
1905   1              y1 = time.years % 10;
1906   1              rtcRegWrite( 0xA0 | y1 );
1907   1              
1908   1              // 10-year
1909   1              y10 = time.years / 10;
1910   1              rtcRegWrite( 0xB0 | y10 );
1911   1              
1912   1              // Day of the week
1913   1              rtcRegWrite( 0xC0 | time.week );
1914   1              
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 32  

1915   1      } // end rtcSetTime()
1916          
1917          // -------------------------------------------------------------- //
1918          
1919          struct time_data rtcGetTime( void ) {
1920   1              
1921   1              struct time_data time;
1922   1              byte s1, s10, mi1, mi10, h1, h10, d1, d10, mo1, mo10, y1, y10, w;
1923   1              
1924   1              s1 = rtcRegRead( 0x00 );
1925   1              s10 = rtcRegRead( 0x01 );
1926   1              time.seconds = s1 + ( s10 * 10 );
1927   1      
1928   1              mi1 = rtcRegRead( 0x02 );
1929   1              mi10 = rtcRegRead( 0x03 );
1930   1              time.minutes = mi1 + ( mi10 * 10 );
1931   1      
1932   1              h1 = rtcRegRead( 0x04 );
1933   1              h10 = rtcRegRead( 0x05 );
1934   1              time.hours = h1 + ( h10 * 10 );
1935   1      
1936   1              d1 = rtcRegRead( 0x06 );
1937   1              d10 = rtcRegRead( 0x07 );
1938   1              time.days = d1 + ( d10 * 10 );
1939   1      
1940   1              mo1 = rtcRegRead( 0x08 );
1941   1              mo10 = rtcRegRead( 0x09 );
1942   1              time.months = mo1 + ( mo10 * 10 );
1943   1      
1944   1              y1 = rtcRegRead( 0x0A );
1945   1              y10 = rtcRegRead( 0x0B );
1946   1              time.years = y1 + ( y10 * 10 );
1947   1      
1948   1              w = rtcRegRead( 0x0C );
1949   1              time.week = w;
1950   1      
1951   1              return time;
1952   1              
1953   1      } // end rtcSetTime()
1954          
1955          // -------------------------------------------------------------- //
1956          
1957          void rtcPrintTime( struct time_data *time ) {
1958   1      
1959   1              char timeStr[] = "0 00/00/00 00:00:00`";
1960   1      
1961   1              sprintf( timeStr, "%d %02d/%02d/%02d %02d:%02d:%02d`", 
1962   1                              (int)time->week, 
1963   1                              (int)time->months, (int)time->days, (int)time->years, 
1964   1                              (int)time->hours, (int)time->minutes, (int)time->seconds );
1965   1              lcdString( &timeStr );
1966   1      
1967   1      } // end rtcPrintTime()
1968          
1969          // -------------------------------------------------------------- //
1970          
1971          void missionControl1( int dec ) {
1972   1              
1973   1              switch ( dec ) {
1974   2                      
1975   2                      // The MSB is changed first to avoid false triggers of the LCD enable
1976   2                      // line as the enable line never goes high when the MSB is low.
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 33  

1977   2                      case ctrl_off: {
1978   3                              dec2 = 0;
1979   3                              dec1 = 0;
1980   3                              dec0 = 0;
1981   3                              break;
1982   3                      }
1983   2                      case ctrl_ss_latch: {
1984   3                              dec2 = 0;
1985   3                              dec1 = 0;
1986   3                              dec0 = 1;
1987   3                              break;
1988   3                      }
1989   2                      case ctrl_kp_oe: {
1990   3                              dec2 = 0;
1991   3                              dec1 = 1;
1992   3                              dec0 = 0;
1993   3                              break;
1994   3                      }
1995   2                      case ctrl_kp_oelatch: {
1996   3                              dec2 = 0;
1997   3                              dec1 = 1;
1998   3                              dec0 = 1;
1999   3                              break;
2000   3                      }
2001   2                      case ctrl_lcd_cmd_start: {
2002   3                              dec2 = 1;
2003   3                              dec1 = 0;
2004   3                              dec0 = 0;
2005   3                              break;
2006   3                      }
2007   2                      case ctrl_lcd_cmd_finish: {
2008   3                              dec2 = 1;
2009   3                              dec1 = 0;
2010   3                              dec0 = 1;
2011   3                              break;
2012   3                      }
2013   2                      case ctrl_lcd_data_start: {
2014   3                              dec2 = 1;
2015   3                              dec1 = 1;
2016   3                              dec0 = 0;
2017   3                              break;
2018   3                      }
2019   2                      case ctrl_lcd_data_finish: {
2020   3                              dec2 = 1;
2021   3                              dec1 = 1;
2022   3                              dec0 = 1;
2023   3                              break;
2024   3                      }               
2025   2              } // end switch
2026   1              
2027   1      } // end missionControl1()
2028          
2029          // -------------------------------------------------------------- //
2030          
2031          void missionControl2( int dec ) {
2032   1              
2033   1              switch ( dec ) {
2034   2                      case ctrl_off: {
2035   3                              dec4 = 0;
2036   3                              dec3 = 0;
2037   3                              dec5 = 0;
2038   3                              break;
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 34  

2039   3                      }
2040   2                      case ctrl_adc_start: {
2041   3                              dec4 = 0;
2042   3                              dec3 = 1;
2043   3                              dec5 = 0;
2044   3                              break;
2045   3                      }
2046   2                      case ctrl_rtc_rd: {
2047   3                              dec4 = 1;
2048   3                              dec3 = 0;
2049   3                              dec5 = 0;
2050   3                              break;
2051   3                      }
2052   2                      case ctrl_adc_finish: {
2053   3                              dec4 = 1;
2054   3                              dec3 = 1;
2055   3                              dec5 = 0;
2056   3                              break;
2057   3                      }
2058   2                      case ctrl_rtc_cs1: {
2059   3                              dec4 = 0;
2060   3                              dec3 = 0;
2061   3                              dec5 = 1;
2062   3                              break;
2063   3                      }
2064   2                      // not used
2065   2      //              case ctrl_rtc_cs0: {
2066   2      //                      dec5 = 1;
2067   2      //                      dec4 = 0;
2068   2      //                      dec3 = 1;
2069   2      //                      break;
2070   2      //              }
2071   2                      case ctrl_rtc_cs0: {
2072   3                              dec4 = 1;
2073   3                              dec3 = 0;
2074   3                              dec5 = 1;
2075   3                              break;
2076   3                      }
2077   2                      case ctrl_rtc_wr: {
2078   3                              dec4 = 1;
2079   3                              dec3 = 1;
2080   3                              dec5 = 1;
2081   3                              break;
2082   3                      }               
2083   2              } // end switch
2084   1              
2085   1      } // end missionControl2()
2086          
2087          // -------------------------------------------------------------- //
2088          
2089          void msDelay( unsigned msecs ) {
2090   1              
2091   1              unsigned i;
2092   1              unsigned char j;
2093   1              
2094   1              msecs = msecs * 3.23;
2095   1              
2096   1              for(i=0;i<msecs;i++){
2097   2                      for(j=0;j<100;j++);
2098   2              }
2099   1              
2100   1      } // end msDelay()
C51 COMPILER V9.02   COMPDESIGNPROJECT                                                     05/05/2017 16:48:52 PAGE 35  

2101          
2102          // -------------------------------------------------------------- //
2103          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6982    ----
   CONSTANT SIZE    =    888    ----
   XDATA SIZE       =   ----    1227
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
